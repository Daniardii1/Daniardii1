<h1 align="center">Hi üëã, I'm Daniel Cifuentes Jimenez</h1>
<h3 align="center">A passionate software developer from Spain</h3>

- üå± I‚Äôm currently learning **C#, SOLID and Clean Code, Docker and design patterns among others**

<h3 align="left">Connect with me:</h3>
<p align="left">
<a href="https://twitter.com/daniardii1" target="blank"><img align="center" src="https://raw.githubusercontent.com/rahuldkjain/github-profile-readme-generator/master/src/images/icons/Social/twitter.svg" alt="daniardii1" height="30" width="40" /></a>
<a href="https://www.linkedin.com/in/daniel-cifuentes-jimenez/" target="blank"><img align="center" src="https://raw.githubusercontent.com/rahuldkjain/github-profile-readme-generator/master/src/images/icons/Social/linked-in-alt.svg" alt="https://www.linkedin.com/in/daniel-cifuentes-jimenez/" height="30" width="40" /></a>
</p>

<h3 align="left">Languages and Tools:</h3>
<p align="left"> <a href="https://www.w3schools.com/cs/" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/csharp/csharp-original.svg" alt="csharp" width="40" height="40"/> </a> <a href="https://www.w3schools.com/css/" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/css3/css3-original-wordmark.svg" alt="css3" width="40" height="40"/> </a> <a href="https://www.djangoproject.com/" target="_blank" rel="noreferrer"> <img src="https://cdn.worldvectorlogo.com/logos/django.svg" alt="django" width="40" height="40"/> </a> <a href="https://dotnet.microsoft.com/" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/dot-net/dot-net-original-wordmark.svg" alt="dotnet" width="40" height="40"/> </a> <a href="https://git-scm.com/" target="_blank" rel="noreferrer"> <img src="https://www.vectorlogo.zone/logos/git-scm/git-scm-icon.svg" alt="git" width="40" height="40"/> </a> <a href="https://www.w3.org/html/" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/html5/html5-original-wordmark.svg" alt="html5" width="40" height="40"/> </a> <a href="https://www.java.com" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/java/java-original.svg" alt="java" width="40" height="40"/> </a> <a href="https://www.linux.org/" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/linux/linux-original.svg" alt="linux" width="40" height="40"/> </a> <a href="https://www.mysql.com/" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/mysql/mysql-original-wordmark.svg" alt="mysql" width="40" height="40"/> </a> <a href="https://www.python.org" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/python/python-original.svg" alt="python" width="40" height="40"/> </a> <a href="https://www.typescriptlang.org/" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/typescript/typescript-original.svg" alt="typescript" width="40" height="40"/> </a> </p>

**C#**

Se trata de un lenguaje de *alto nivel* y *POO*, dise√±ado por Microsoft para la plataforma .NET. En cuanto a sus caracter√≠sticas se encuentran: 

- ***Tipado est√°tico (***y adem√°s ***fuertemente tipado)***, pues las variables y expresiones deben ser declaradas con un tipo espec√≠fico y su tipo no puede cambiar durante la ejecuci√≥n del programa. 
- ***Gesti√≥n autom√°tica de memor√≠a,*** ya que utiliza un recolector de basura para gestionar la memoria, lo que quiere decir que el programador no debe preocuparse por liberar memoria utilizada por objetos que ya no se utilizan. 
- ***Seguridad de tipos,*** ya que realiza comprobaciones en tiempo de compilaci√≥n para garantizar que los tipos de las variables y expresiones son coherentes y seguros. 
- ***Interoperabilidad,*** pues est√° dise√±ado para funcionar en conjunto con otros lenguajes y tecnolog√≠as de .NET, como Visual Basic, C++ y ASP.NET. 
- ***Multiplataforma,*** pues a partir de la llegada de .NET Core, los programas escritos en C# puede ejecutarse en Windows, macOS y Linux. 
- ***Asincr√≥nico,*** pues cuenta con un fuerte soporte para la programaci√≥n asincr√≥nica, permitiendo programas que realicen m√∫ltiples tareas en paralelo. Esto se lleva a cabo con palabras clave como *async* y *await.* 

C# es un lenguaje dise√±ado para compilar a **CIL (Common Intermediate Language,** antes conocido como MSIL, *Microsoft Intermediate Language***)** y, posteriormente, ser ejecutado en la plataforma .NET a trav√©s del **CLR (Common Language Runtime)**, esta pr√°ctica es la que hace posible que el c√≥digo C# se pueda ejecutar en diferentes plataformas, ya que CIL es independiente de las plataformas, por lo que mientras la plataforma tenga instalado el CLR correspondiente podr√° ejecutar la aplicaci√≥n. 



**CIL ‚Üí** Es un lenguaje intermedio utilizado por .NET y generado por el compilador de C# (o cualquier otro lenguaje .NET). Este lenguaje es independiente de la plataforma, y aunque se parece al lenguaje ensamblador, es m√°s f√°cil de leer y escribir y de m√°s alto nivel. Sus instrucciones se llaman *opcodes* y representan todas las operaciones que se pueden realizar en .NET, √©stas son compiladas en c√≥digo nativo y posteriormente ejecutadas por el  CLR. 

**CLR ‚Üí** Entorno de ejecuci√≥n de tiempo de ejecuci√≥n que compila el c√≥digo CIL en c√≥digo m√°quina para que se pueda ejecutar en el SO subyacente. Adem√°s proporciona caracter√≠sticas importantes como la **gesti√≥n autom√°tica de la memoria, el control de excepciones, la seguridad de tipos y la recolecci√≥n de basura**; as√≠ como una amplia biblioteca de clases y tipos base. 

- **Garbage collector ‚Üí** se encarga de administrar la memoria utilizada por los programas en tiempo de ejecuci√≥n. Su objetivo principal es liberar la memoria que ya no es necesaria o que ha quedado inaccesible para el programa, evitando as√≠ fugas de memoria o errores por referencias inv√°lidas, es decir permite administrar de forma segura. Es el encargado de permitir la **gesti√≥n autom√°tica de memoria**. 

Cuando hablamos de ***unmanaged resources (recursos no administrados)*** debemos de tener en cuenta que entonces somos nosotros los encargados de administrar manualmente la memoria y de liberarla, para ello debemos usar el m√©todo .**Dispose()** que libera la memoria de ese componente. 

-----

<a name="_pix1r13fo965"></a>**ESTRUCTURA PROYECTO**

- **.sln ‚Üí** archivo de soluci√≥n de VS, es un archivo de texto que describe la estructura del proyecto. Contiene informaci√≥n sobre qu√© proyectos se incluyen en la soluci√≥n, c√≥mo se relacionan entre s√≠ y c√≥mo se construyen. Tambi√©n tiene informaci√≥n sobre la configuraci√≥n de depuraci√≥n y lanzamiento. 
- **.csproj ‚Üí** archivo de proyecto de VS, es un archivo XML que describe los archivos que se incluyen en el proyecto, as√≠ como sus referencias, propiedades y configuraci√≥n de compilaci√≥n. Es el archivo utilizado por el compilador de C# para generar el archivo ejecutable. 
- **.cs ‚Üí** archivos de c√≥digo fuente de C# que contienen el c¬¥dogio que define las clases, interfaces y otros tipos que se utilizan en el proyecto, son los que contienen la l√≥gica de la aplicaci√≥n y se compilan para generar el archivo ejecutable. 
-----

<a name="_1hd20mkh29x0"></a>**SINTAXIS** 

La **sintaxis** es la apariencia y estructura del c√≥digo; mientras que la **sem√°ntica** es lo que representa las partes del c√≥digo, permiti√©ndonos conocer c√≥mo se comporta al ejecutarse. 

Todas las **sentencias** en C# deben terminar con **;** . 

<a name="_4bnnmdbeqtic"></a>**Tipos de datos**

Existen dos tipos de conversiones de datos: 

- **Conversi√≥n impl√≠cita/autom√°tica ‚Üí**  la cual es permitida √∫nicamente entre los siguientes tipos de datos: 

- sbyte ‚Üí short, int, long, float, double, decimal
- byte ‚Üí short, ushort, int, uint, long, ulong, float, double, decimal
- short ‚Üí int, long, float, double, decimal
- ushort ‚Üí int, uint, long, ulong, float, double, decimal
- int ‚Üí long, float, double, decimal
- uint ‚Üí long, ulong, float, double, decimal
- long ‚Üí float, double, decimal
- char ‚Üí ushort, int, uint, long, ulong, float, double, decimal
- float ‚Üí double

Cabe destacar que si el valor a convertir no se encuentra dentro del rango permitido por el tipo de destino, se producir√° un error, pues para que sea posible se requerir√° de una conversi√≥n expl√≠cita mediante el operador de conversi√≥n correspondiente. 

- **Conversi√≥n expl√≠cita ‚Üí** aquella en la que se especifica de forma expl√≠cita una conversi√≥n de un tipo de dato a otro mediante una expresi√≥n de conversi√≥n. P.e **(tipodedatonuevo)datoviejo**

Otra opci√≥n para realizar una conversi√≥n segura de tipos (**casting**) es a trav√©s de **as** que en caso de no poder realizar la conversi√≥n porque √©sta sea incompatible, devuelve un ***null***, en vez de lanzar una excepci√≥n. **tipodedatoviejo as tipodedatonuevo** P.e 

**object obj = ‚ÄúHola mundo‚Äù;** 

**string str = obj as string;** 

**if (str != null)** 

**{**

`     `**Console.WriteLine(str);**

**}**

**else** 

**{**

`      `**Console.WriteLine(‚ÄúNo se pudo convertir el objeto a string.‚Äù);**

**}**

**>Tipos de datos simples/b√°sicos/primitivos** que permiten almacenar un √∫nico valor, el cual se encuentra en la memoria (esto quiere decir que las variables de estos tipos de datos contienen una copia del valor real en lugar de una referencia a una ubicaci√≥n de memoria). Datos que se almacenan en la pila/steak.  

**Nota ‚Üí** en C# es posible el uso de **var** tambi√©n en los tipos de datos simples (tal y como ocurre con los complejos) permitiendo declarar variables (a la vez que se inicializan, sino no funciona) sin indicar expl√≠citamente el tipo, ya que el compilador toma el tipo seg√∫n lo que se indique a la derecha. Esta pr√°ctica **solo es posible dentro de m√©todos y bucles.** 

P.e 	

**var nombreVariable = valorVariable;**	     en vez de	**tipodeDato nombreVariable = valorVaribale;** 

- Tipos num√©ricos enteros ‚Üí hay 4 tipos para almacenar enteros en Java. Se diferencian entre s√≠ por el n¬∫ de bytes utilizados en el almacenamiento y el rango de valores que pueden representar. Permiten el almacenamiento de n√∫meros negativos y positivos. 

- **Bytes ‚Üí** Variable m√°s peque√±a que ocupa un √∫nico byte en memoria. 

Puede ser ***byte*** que va de 0 a 255 o bien ***sbyte*** que tiene en cuenta el signo y va de -128 a 127. 

**byte nombrevar = num;** 

- **Short ‚Üí** almacena valores de -32768 a 32767 y ocupa 2 bytes de memoria. Tambi√©n puede ser ***ushort*** en cuyo caso va desde 0 a 65535.	     **short nombrevar = num;** 

- **Int ‚Üí** almacena valores -2\*10^9 a 2\*10^9 y ocupa 4 bytes de memoria. Tambi√©n puede ser ***uint*** en cuyo caso va desde 0 a 4\*10^9.	**int nombrevar = num;** :

- **Long ‚Üí** es mucho m√°s grande que el anterior y ocupa 8 bytes. Se utiliza tambi√©n para contener datos digitales. Siguiendo el mismo patr√≥n de short e int, existe ***ulong***. 

**long creditCardNumber= 1234\_5678\_9012\_3456L;;** 

- Tipos num√©ricos en punto flotante ‚Üí permiten representar n√∫meros muy grandes y peque√±os, adem√°s de decimales. Cabe destacar que se admite el uso de **separadores de n√∫meros \_** haciendo m√°s legible los n√∫meros largos; el uso de **en¬∫, En¬∫.**  

- **Float ‚Üí** permite contener decimales simples (hasta 7 decimales de precisi√≥n) y ocupa 4 bytes de memoria. Para considerarse un float deber√° de indicarse el sufijo **f o F**.  

- **Double ‚Üí** se usa exclusivamente para decimales dobles (hasta 15 decimales de precisi√≥n) y ocupa 8 bytes. Se suele utilizar en aplicaciones cient√≠ficas y de ingenier√≠a donde se necesitan c√°lculos complejos y un rango de valores m√°s amplio (-1,7 \* 10^308 a 1,7 \* 10^308). Si **no se indica sufijo** o se indica **d o D** se considerar√° un double.

- **Decimal ‚Üí** se diferencia del anterior porque tiene mayor rango (hasta 28-29 decimales de precisi√≥n) y ocupa 16 bytes. Suele ser utilizado en aplicaciones financieras donde se requiere de alta precisi√≥n decimal (-7,9 \* 10^28 a 7,9 \* 10^28). Para considerar un decimal se deber√° indicar el sufijo **m o M**. 

Se recomienda, que cuando queramos inicializar una variable de tipo decimal a 0, en vez de usar 0 directamente usemos *decimal.Zero*. 

- **Boolean ‚Üí** sus valores pueden ser ***True*** o ***False***, o lo que es lo mismo **1** o **0**.	**boolean nombrevar = false/true;** 

- **Char ‚Üí** almacena un solo car√°cter y ocupa 2 bytes. Se usa ‚Äò ‚Äò. 		**char nombrevar = ‚Äòchar‚Äô;** 

**>Tipos de datos complejos/estructurados - clase - objeto/de referencia**, que permiten almacenar m√∫ltiples valores de tipos primitivos m√°s simples (del mismo tipo o no), al mismo tiempo. Estos reciben el nombre de **objetos** porque se utilizan para representar objetos. En este caso, los tipos contienen una referencia a una ubicaci√≥n de memoria en la que se almacena el valor real. Estos se almacenan en el **mont√≥n/heap**, por eso la gesti√≥n de la memoria que ocupan es m√°s compleja y menos eficiente. 

**Nota ‚Üí** en C# es posible el uso de **var** para ahorrar tiempo de escritura de c√≥digo, lo que permite es que al instanciar objetos de tipos complejos solo de deba indicar el tipo a la derecha de la instancia tras la palabra new, sin tener que hacerlo a la izquierda de la instancia previo al nombre de la instancia. Pues al poner var se entiende que el nombre de la instancia ser√° del tipo que se indique a la derecha. Hay que tener mucho cuidado con esta pr√°ctica ya que a veces puede hacer m√°s dif√≠cil la lectura del c√≥digo y en algunas empresas puede prohibir y/o restringir su uso. Esta pr√°ctica **solo es posible dentro de m√©todos y bucles.**

Es **√∫til para crear tipos an√≥nimos ‚Üí var nombreObj = new {};**

P.e 

**var nombreObj = new TipodeDato();** 	   en vez de 	**TipodeDato nombreObj = new TipodeDato();** 

- **Cadenas de caracteres ‚Üí** a pesar de que se considera un objeto, cuando declaramos una cadena lo hacemos igual que con los tipos de datos simples/primitivos. Cabe destacar que un objeto String es **inmutable,** es decir, no se pueden modificar despu√©s de haberse creado, por lo que los m√©todos que parecen modificar un String devuelven realmente un nuevo String que contiene la modificaci√≥n. 

**String ‚Üí** Almacena un conjunto de caracteres. Se usa ‚Äú ‚Äú.  Si quisi√©ramos hacer un bloque de texto podemos hacer usando **+** o bien poner el bloque de texto entre **‚Äú‚Äù‚Äù ‚Äú‚Äù‚Äù** (tres comillas dobles), en cuyo caso tenemos que tener en cuenta que los espacios en blanco consecutivos y las tabulaciones se eliminan, por lo que si queremos tabular o usar m√°s de un espacio debemos usar el gui√≥n medio **-** .

Todos los tipos de datos b√°sicos puede ser transformados a String, basta con que usemos el m√©todo **toString** de la clase que recoge dicho tipo de dato, por ejemplo para pasar un integer y un float a string bastar√≠a con **Integer.toString(n¬∫ a convertir);** y **Float.toString(n¬∫).**  Cabe destacar que no es una conversi√≥n real, sino que devuelve una instancia de String. 

[**M√©todos y operadores con cadenas](https://learn.microsoft.com/es-es/dotnet/api/system.string?view=net-7.0#Immutability)** 

**Interpolaci√≥n de cadenas**

Una **cadena interpolada** es aquella en la que se pueden incluir expresiones de interpolaci√≥n (variables o expresiones, incluidos objetos, arrays, operaciones, m√©todos, etc‚Ä¶). Para ello, la sintaxis a utilizar es: 

`	`**$‚Äù*aqu√≠ va la cadena  {aqu√≠ va la expresi√≥n o variable}*‚Äú**  

**>**Cabe destacar que no puede existir espacio entre $ y ‚Äú, y que se puede aplicar sobre bloques de cadena, es decir cuando usemos ‚Äú‚Äù‚Äù ‚Äú‚Äù‚Äù‚Äù. 

**>**Por otro lado,  si queremos **formatear** las expresiones y/o variables dentro de las llaves, tambi√©n es posible, utilizando una sintaxis especial, como p.e 

{numero:f2} donde f2 indica el n¬∫ de decimales con el que queremos mostrar *numero*. En vez de **f** para indicar el **n¬∫ de decimales**, podemos usar **c** para el **valor monetario**, **d** para indicar que sea un **entero**, **p** para indicar porcentajes (con el n¬∫ indicamos el n¬∫ de decimales), **e** para indicar en formato de **n¬∫ e**, . 

Es importante saber que ocurre lo mismo con el formateo de Datetime (tema extenso que se tocar√° en otro apartado). 

**>**Si queremos incluir llaves dentro de la cadena (es decir, que se vean como parte del texto) , basta con indicar **{{ ‚Ä¶ }}.** Esto se debe a que dependiendo del n¬∫ de **$** al principio, se considerar√°n { cuando haya un n¬∫ mayor de { seguidas que el n¬∫ de $. P.e $$‚Äù ‚Ä¶ ‚Äú entonces se considerar√° { dentro del texto cuando hayan {{{, es decir >2 llaves seguidas. 

**>**Dado que los **dos puntos** se suelen usar en muchas expresiones de interpolaci√≥n, si queremos que √©stos aparezcan como parte del texto debemos poner antes **\**. Ocurre lo  mismo si queremos usar **comillas dentro de comillas**. 

**>**Si queremos indicar una expresi√≥n de interpolaci√≥n que sea un operador condicional como el **operador ternario**, √©ste debemos indicarlo entre par√©ntesis {(aqu√≠ va el operador ternario)}. 

**>**Dentro de las {}, la sintaxis a utilizar podr√° tambi√©n ser de la siguiente forma 

**{expr/varDeInterpolaci√≥n},alineaci√≥n:formato}** 

Donde la **alineaci√≥n** es un entero con signo que indica el ancho de campo, es decir la tabulaci√≥n y/o margen que hay  entre la la expresi√≥n o variable y el resto de palabras. Si el valor es < longitud de la cadena se omite y se utiliza la longitud de la cadena como el ancho. Si el n¬∫ es positivo, se considera que los elementos est√°n alineados a la derecha, por el contrario si es negativo se considerar√° que es la alineaci√≥n a la izquierda. Es importante que, si queremos usar alineaci√≥n indiquemos la coma previamente. 


- **Arrays ‚Üí** Colecci√≥n de datos del mismo tipo, es decir un conjunto de datos/elementos donde cada uno se representa en una posici√≥n que est√° identificada gracias a uno o m√°s √≠ndices num√©ricos enteros (empieza en 0). El **tama√±o de un array no se puede modificar una vez creado**. 

La sintaxis para declararlo es (aunque cabe destacar que podemos declarar por un lado y posteriormente crear el objeto indicando el tama√±o): 

`	`**tipodedato[] nombredelarray=new tipodedato[cantidad de datos];**	//Array de una dimensi√≥n | **vectores** 

`	`**tipodedato[,] nombredelarray=new tipodedato[cant de datos 1¬™ Dim, cant de datos 2¬™Dim];**     //Array de dos dimensiones | **matrices**
**
`										        `//1¬™Dim = Filas ||2¬™Dim = Columnas

\*\*Nota, si se trata de un array de tipos de datos simples, basta con poner **nombredelarray=new tipodedato[]**. 

Para escribir datos en un array la sintaxis es: 

**nombredelarray[posici√≥nqueocupaeldato] = dato;**

Si queremos declarar y dar valor a la vez, podemos hacerlo de la siguiente manera: 

**tipodedato[] nombredelarray = new tipodedato[] {ponemos el valor de los datos separados por comas};**     //tipos simples

//El tama√±o del array ser√° igual al n¬∫ de datos introducidos 

**tipodedato[] nombredelarray = new tipodedato[]** 

**{**

**new tipodedato(argumentosconstructor), tantos como queramos**

**};**     //tipos complejos

`       `//El tama√±o del array ser√° igual al n¬∫ de datos introducidos 

Para recorrer los elementos de un array, ser√° necesario el uso del bucle for, iniciando en 0 hasta el tama√±o del array, el cual podremos conocer usando la funci√≥n **nombredelarray.length** (esta devuelve el tama√±o del array, recordemos que si el tama√±o es 5 y yo solo he inicializado 3, lo 2 restantes igualmente tendr√°n el valor predeterminado, p.e 0 si fuesen elementos de tipo entero). Otra opci√≥n es usar un **bucle for each** que se usa de la siguiente manera (*por cada tipodedato ‚Äúdato‚Äù que est√© en nombrarray hacemos {. . .})*: 

`	`**for (tipodedato dato: nombrearray) {**

`	`**System.out.println(‚ÄúEl dato es: ‚Äú + (dato)));**

**}**

Para usar el valor contenido en alguna posici√≥n:  **nombredelarray[posicion]**

Podemos encontrar varias [**propiedades](https://learn.microsoft.com/es-es/dotnet/api/system.array?view=net-7.0#properties) **y  [m√©todos](https://learn.microsoft.com/es-es/dotnet/api/system.array?view=net-7.0#methods)** de clase Array que pueden resultar muy √∫tiles para trabajar con ellos.**  

- **Enumeraci√≥n ([Explicaci√≥n y Ejemplos](http://puntocomnoesunlenguaje.blogspot.com/2013/04/java-enum-enumerados-en-java.html)) ‚Üí** tipo de datos definido por el usuario que solo puede tomar como valores los definidos en una lista de constantes. Por convenio se suelen escribir los valores del enun en may√∫sculas al tratarse de constantes 

Para declararlo (se pueden declarar dentro y fuera de4 una clase pero nunca dentro de un m√©todo): 

`	`**enum nombredelEnum {VALOR1, VALOR2, VALOR3‚Ä¶};** 

Para declarar variable del tipo enumCreado: 

**nombredelEnum nombreVariable;** 

Para inicializar la variable de nuestro tipo enum, no obstante, cabe destacar que podemos declarar la variable e inicializarla a la vez: 

**nombreVariable = nombredelEnum.VALOR;** 

Entre los m√©todos que proporciona este tipo de dato se encuentran: 

- **name() ‚Üí** devuelve un string con el nombre de la constante que contiene. 
- **ordinal() ‚Üí** devuelve un entero con la posici√≥n de la constante seg√∫n est√° declarada en el enum. La primera constante corresponde a la posici√≥n cero. 
- **toString()**
- **equals(objetoAComparar)** 
- **compareTo(enumAComparar) ‚Üí** permite comparar el enum que usa el m√©todo con el enum que se pasa como argumento, de forma que se van comparando la cte de un enumerado con la equivalente a la posici√≥n del otro enum. Devuelve un n¬∫ negativo, cero o un n¬∫ positivo seg√∫n el objeto sea menor, igual o mayor que el que recibe como par√°metro. 
- **values() ‚Üí** devuelve un array que contiene todas las constantes de la enumeraci√≥n que est√° usando el m√©todo. 

Es importante saber que al ser un **tipo creado por el usuario** puede contener **m√©todos** y **atributos**: 

- El constructor debe ser **private** o **package** pero no public. 
- Los valores constantes deben estar relacionados con un atributo. Las constantes se deben definir primero, antes que cualquier otro atributo o m√©todo, y en caso de que hayan atributos o m√©todos se deben de terminar con **;** . 
- No debe contener m√©todos de tipo *set* ya que los valores que se relacionan con las constantes, se deben asignar en el constructor cuando se crean y ya no se pueden modificar. 

Ejemplo

**//Declaraci√≥n del enum**

**public enum Precios {** 

`     `**PRECIONORMAL(100), PRECIOVIP(80);  //los valores se pasan al constructor**                                     

`     `**private double precio;**

`     `**private Precios(double p){**

`         `**precio = p;**

`     `**}**

`     `**public double getPrecio() {**

`         `**return precio;**

`     `**}**

**}**

**//Clase principal**

**public class Enum3 {**  

`    `**public static void main(String[] args) {**

`        `**Precios p = Precios.PRECIOVIP;     //precio = 80**                                                          

`        `**System.out.println(p.getPrecio()); //muestra 80**

`    `**}**

**}**


- **Colecci√≥n ‚Üí** es un objeto que a su vez contiene un conjunto de objetos. Se diferencia del array en que el array  es un objeto con elemento est√°tico de cierta longitud, por ello se debe especificar la cantidad de elemento que contiene sin poderse modificar; adem√°s puede tener objetos vac√≠os y, en lugar de devolver el n¬∫ real de elementos presentes en √©l, devuelve su capacidad. Mientras que la colecci√≥n es un objeto con un **conjunto din√°mico de elementos,** esto quiere decir que puede aumentar o disminuir y que su tama√±o depende del n¬∫ real de elementos que contiene (no puede contener huecos a menos que el programador lo especifique). 

.NET proporciona muchas colecciones comunes. Cada **tipo de colecci√≥n** est√° dise√±ada para un fin espec√≠fico, variando en c√≥mo almacenan, ordenan y comparan elementos y c√≥mo realizan b√∫squedas. Entre las m√°s comunes se encuentran [(recomendaciones seg√∫n uso)](https://learn.microsoft.com/es-es/dotnet/standard/collections/#choose-a-collection) : 

- ***System.Collections.Generic ‚Üí*** espacio de nombres que contiene las **clases de colecciones gen√©ricas** en .NET. Una colecci√≥n gen√©rica es √∫til cuando todos los elementos de la colecci√≥n tienen el mismo tipo, esto hace que estas colecciones proporcionen mayor seguridad de tipos (al permitir agregar solo los tipos de datos deseados) y un mejor rendimientos que las colecciones no gen√©ricas del espacio de nombre *System.Collections.* 

Entre las **clases m√°s comunes** que incluye este espacio de nombres se encuentran: 

- **List<T> ‚Üí** lista din√°mica de objetos del tipo T. Funciona muy similar a un Array (se pueden acceder los elementos mediantes **√≠ndice basado en 0**) pero con las peculiaridades y diferencias de las colecciones. 

La sintaxis para crear una lista ‚Üí 

**List<tipoDeDato> NombreDeLista = new List<tipoDeDato>();**  //tipos simples 

`	`**List<tipodedato> NombreDeLista = new List<tipodedato>()** 

**{**

**new tipodedato(argumentosconstructor), tantos como queramos**

**};**     //tipos complejos

Por otro lado, en cuanto a sus **m√©todos** m√°s comunes se encuentran: 

- **.Add(T item) ‚Üí** a√±ade un elemento al final de la lista. 
- .**AddRange(List<T> list) ‚Üí** permite agregar una lista a la actual. 
- **.Insert(int index, T item) ‚Üí** inserta un elemento en la lista en el √≠ndice especificado. 
- **.Remove(T item) ‚Üí** elimina la primera aparici√≥n del elemento especificado de la lista. 
- **.RemoveAt(int index) ‚Üí** elimina el elemento en el √≠ndice especificado de la lista. 
- **.Contains(T item) ‚Üí** determina si un elemento est√° en la lista. 
- **.IndexOf(T item) ‚Üí** devuelve el √≠ndice de la primera aparici√≥n del elemento especificado en la lista. En caso de que dicho elemento no exista, devuelve un -1. 
- **.Sort() ‚Üí** se trata de un m√©todo **mutable** (modifica los valores del objeto en el que se usa). Ordena los elementos de la lista.  
- **Count ‚Üí** es una **propiedad** de List<T> que almacena el n¬∫ de elementos de la lista. 

- **Queue<T>  ‚Üí** Son listas que siguen un orden FIFO. Podemos decir que su funcionamiento de adici√≥n es igual al de una pila; sin embargo la salida de los elementos es inversa, similar a cuando hacemos una cola para entrar a un sitio. Hay que tener en cuenta que cuando iteramos en una cola empezamos a recorrerla desde el principio de la misma, por ello vamos a ver que la iteraci√≥n es inversa a lo que ocurre en la pila.  

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.001.png)

`	`**nombreCola.Enqueue(T item);**		//A√±adir elemento al final de la cola

`	`**nombreCola.Dequeue();**		//Elimina y devuelve el primer elemento de la cola

`	`**nombreCola.Peek();** 			//Devuelve el primer elemento de la cola sin eliminarlo

- **Stack<T> ‚Üí** Son listas que siguen un orden LIFO. Podemos decir que su funcionamiento de adici√≥n es igual al de una cola; sin embargo la salida de los elementos es inversa, similar a como vamos apilando los platos y as√≠ mismo los vamos cogiendo de la torre. Hay que tener en cuenta que cuando iteramos en una pila empezamos a recorrerla desde la cima (top de la misma), por ello vamos a ver que la iteraci√≥n es inversa a lo que ocurre en la cola. 

`	`**nombrePila.Push(T item);**		//A√±adir elemento al top de la pila (como los platos apilados)![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.002.png)

`	`**nombrePila.Pop();**			//Elimina y devuelve el primer elemento de la pila, es decir el del top)

`	`**nombrePila.Peek();** 			//Devuelve el primer elemento de la pila sin eliminarlo, el del top

- **LinkedList<T> ‚Üí** colecci√≥n de elementos organizados en una lista enlazada. Los elementos pueden ser insertados o eliminados de la lista de manera eficiente en cualquier posici√≥n, es decir a diferencia de una pila o cola, permite el acceso aleatorio.  

Si vamos agregar/borrar elementos constantemente, se recomienda usar mejor este tipo de lista que la lista normal, ya que por c√≥mo se configuran, LinkedList es mucho m√°s eficiente. [Buena explicaci√≥n de esta diferencia](https://www.youtube.com/watch?v=MYPtLPL0oCQ&ab_channel=pildorasinformaticas) 

- **Dictionary<TKey, TValue> ‚Üí** colecci√≥n de pares de clave y valor que se organizan seg√∫n la clave, es decir en vez de utilizar √≠ndices para acceder a los valores, se utiliza la clave. 



- **HashSet<T> ‚Üí** Colecci√≥n de elementos √∫nicos no ordenados. Se utiliza principalmente para buscar y eliminar elementos duplicados en una colecci√≥n, ya que no pueden haber valores repetidos. 

- **SortedList<TKey, TValue> ‚Üí** Proporciona una versi√≥n ordenada (por clave) de la clase Dictionary<TKey, TValue>. Permite acceder a sus elementos tanto desde el √≠ndice de base cero como por la clave del elemento. 

- ***System.Collections ‚Üí*** espacio de nombres que contiene las **clases de colecciones no gen√©ricas** en .NET. Una colecci√≥n no gen√©rica  es aquella que no almacena los elementos como objetos de tipo espec√≠fico, sino como objetos de tipo *Object*. Es por esto √∫ltimo que decimos que no cuenta con los beneficios de seguridad que las gen√©ricas, y por ello se recomienda usar mejor las gen√©ricas o las pertenecientes al espacio de nombres *System.Collections.Concurrent*. 

- **ArrayList ‚Üí** Internamente funciona como un array, pero su tama√±o puede aumentar o disminuir seg√∫n sea necesario. 
- **Hashtable ‚Üí** colecci√≥n de pares clave-valor no ordenado que se pueden buscar mediante una clave. Es √∫til cuando se necesita un acceso r√°pido a los elementos por clave, pero no se requiere un orden espec√≠fico. 
- **SortedList ‚Üí** Proporciona una versi√≥n ordenada (por clave) de la clase Hashtable. No obstante, tiene un costo de rendimiento ligeramente mayor que Hashtable. 
- **Queue ‚Üí** Son listas que siguen un orden FIFO. 
- **Stack ‚Üí** Son listas que siguen un orden LIFO. 

- ***System.Collections.Concurrent ‚Üí*** espacio de nombres que contiene **clases de colecciones concurrentes** en .NET. Estas clases proporcionan una manera segura para que varios subprocesos accedan y modifiquen colecciones de forma concurrente sin necesidad de bloquear el acceso a la colecci√≥n completa. 

Entre las m√°s comunes se encuentran *ConcurrentBag, ConcurrentDictionary, ConcurrentQueue, ConcurrentStack,* entre otras. 

- ***System.Collections.ObjectModel ‚Üí*** espacio de nombres que contiene clases que implementan colecciones especializadas y proporciona interfaces para implementar colecciones personalizadas. 

- **ObservableCollection<T> ‚Üí** permite implementar colecciones que pueden notificar a sus suscriptores de los cambios en la colecci√≥n. 

- ***System.Collections.Immutable ‚Üí*** espacio de nombres que contiene tanto colecciones gen√©ricas como no gen√©ricas, con la caracter√≠stica de ser inmutables. Estas son √∫tiles cuando se necesita mantener una colecci√≥n constante, inmutable y segura en el tiempo. Permiten garantizar la integridad de los datos y evitar cambios inesperados, por lo que pueden ser √∫tiles en aplicaciones distribuidas y paralelas, ya que permiten el acceso concurrente a los datos sin bloqueos ni sincronizaci√≥n. 


Peculiaridades 

**>** Todas las colecciones que implementan **IEnumerable** o **IEnumerable<T>** se considera **iterable**, por lo que permiten recorrer en iteraci√≥n la colecci√≥n a trav√©s de un foreach, in y For Each‚Ä¶Next. Por otro lado, cualquier colecci√≥n que implementa **IEnumerable<T>** se considera un tipo **consultable** y se puede consultar con LINQ. 

**>** Todas las colecciones se pueden copiar en una matriz unidimensional con l√≠mite inferior de cero mediante el m√©todo **CopyTo**; no obstante el orden de los elementos de la nueva matriz se basar√° en la secuencia en la que los devuelve el enumerador. 

**>** Las colecciones tienen ***capacidad** (n¬∫ de elementos que puede contener)* y ***recuento*** (*n¬∫ de elementos que realmente contiene*). La mayor√≠a expanden autom√°ticamente su capacidad cuando se alcanza la actual (la memoria se reasigna y los elementos de la antigua se copian en la nueva) lo cual reduce el c√≥digo para utilizarla, pero perjudica el rendimiento. Por eso, cuando sea posible se recomienda establecer la capacidad estimada de la colecci√≥n para evitar m√∫ltiples reasignaciones. 

- **Tipos definidos por el usuario ‚Üí** clases para realizar todas las operaciones o tareas posibles (leer y escribir archivos, ejecutar apps, enviar correos,crear cadenas‚Ä¶). 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

<a name="_h1qbkmpqdo6k"></a>**Variables**

**tipodedato  nombredevar = valordevar;** 

*Nombre de la variable* **‚Üí** Todas las variables deben de empezar o bien con una letra o bien con un gui√≥n bajo \_. 

Cada tipo puede almacenar una cantidad de bytes, por lo que si al declarar una variable se supera los bytes para el tipo de dato, la informaci√≥n extra se excluir√° produciendo un error. 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

<a name="_swm9ucwbkyg5"></a>**Operadores** 

- **Aritm√©ticos ‚Üí** utilizados para c√°lculos aritm√©ticos entre variables, cuyo resultado ser√° el valor devuelto como resultado de la operaci√≥n. 

- *Dos operandos* 


|**Operador**|**Uso**|
| :-: | :-: |
|**+ [suma]**|op1 + op2|
|**- [resta]**|op1 - op2|
|**\* [multiplicaci√≥n]**|op1 \* op2|
|**/ [divisi√≥n]**|op1 / op2|
|**% [m√≥dulo]**|<p>resto de la divisi√≥n op1 / op2</p><p></p><p>Si tenemos op1 % op2 = r deber√° de cumplirse la igualdad op1 = op2 \* n¬∫devecesquedcabeenop1 + r </p><p></p><p>Si op1 > op1 entonces el m√≥dulo se hace como hemos visto siempre, hago la divisi√≥n como si fuese entera y lo que me sobre (resto) ser√° el m√≥dulo p.e ‚Üí 8 mod 5 = 3</p><p>Si op1 < op2 entonces el m√≥dulo siempre va a ser D ‚Üí 5 mod 8 = 5 </p><p>Si op1 es un n¬∫ negativo entonces el m√≥dulo va a ser igual a hacer op2 + op1 p.e ‚Üí -5 mod 6 = 1 Es por esto que cuando queramos implementar un contador que va decrementando de 1 en 1 y queremos que una vez llegue a 0, vuelva otra vez a valer lo que val√≠a inicialmente entonces basta con que hagamos: (count - 1) % contadormax</p><p>P.e ‚Üí si mi contador empieza en 5 tendr√≠amos que hacer (count -1) % 6 por lo que count siempre va a ser menor que 6 lo que har√° que el resultado de esa operaci√≥n de m√≥dulo sea siempre count -1, excepto cuando count - 1 = -1 en cuyo caso -1 mod 6 = 5 </p>|



- *Un operando (operadores unarios)*  


|**Operador**|**Uso**|
| :-: | :-: |
|**++ [incremento en 1]**|<p>op++</p><p></p><p>eval√∫a el valor op antes de incrementarlo, por lo que se usa primero op y luego ya se aumenta su valor en 1 </p>|
|**++ [incremento en 1]**|<p>++op</p><p></p><p>eval√∫a el valor op despu√©s de incrementarlo, por lo que primero aumenta op en 1 y luego ya opera con op</p>|
|**-- [decremento en 1]**|<p>op--</p><p></p><p>eval√∫a el valor op antes de decrementarlo, por lo que se usa primero op y luego ya se disminuye su valor en 1 </p>|
|**-- [decremento en 1]**|<p>--op</p><p></p><p>eval√∫a el valor op despu√©s de decrementarlo, por lo que primero disminuye op en 1 y luego ya opera con op</p>|
|**ejemplos**|<p></p><p>int i = 1, j; //declaramos i y j como integers y definimos i a 1</p><p>j = i++; </p><p>//aqu√≠ el valor de j=1 pero i=2 ya que i se incrementa tras producirse la operaci√≥n de asignaci√≥n j = i++; </p><p></p><p>int i = 1, j; //declaramos i y j como integers y definimos i a 1</p><p>j = ++i; </p><p>//aqu√≠ el valor de j=2 e i=2 ya que i se incrementa antes de  producirse la operaci√≥n de asignaci√≥n j = ++i.  </p>|

- **Condicionales ‚Üí** utilizados para decidir entre algunas expresiones de comparaci√≥n simples. El resultado es un boolean (verdadero o falso) que depende de que se cumplan o no las condiciones. 


|**Operador**|**Uso**|
| :-: | :-: |
|**&& [and]**|<p>expresion1  && expresion2</p><p></p><p>Es true cuando ambas condiciones son true, por lo que si op1 es false, directamente ni eval√∫a op2 sino que devuelve false</p>|
|**|| [or]**|<p>expresion1 || expresion2</p><p></p><p>Es false cuando ambas condiciones son false, por lo que si op1 es true, directamente ni eval√∫a op2 sino que devuelve true</p>|
|**! [negaci√≥n]**|<p>! expresion</p><p></p><p>Devuelve el contrario de op, es decir si es true devuelve false y viceversa</p>|
|**& [and]**|<p>expresion1 & expresion2</p><p></p><p>Funciona exactamente igual que and, pero en este caso siempre eval√∫a ambas condiciones con independencia de que la primera sea true o false</p>|
|**| [or]**|<p>expresion1 | expresion2</p><p></p><p>Funciona exactamente igual que or, pero en este caso siempre eval√∫a ambas condiciones con independencia de que la primera sea true o false</p>|
|**:? [ternario if-then-else]**|<p>(expresi√≥n)**?**valor1**:**valor2</p><p></p><p>Funciona como un if-then-else, de forma que se eval√∫a la expresi√≥n y si √©sta es  verdadera se retorna el valor1, de lo contrario se retorna el valor2. Se suele utilizar mucho para decidir qu√© valor asignar. </p><p></p><p>P.e int v1 = 5 //Asignamos 5 a la var. entero v1</p><p>int v2 = 4 //Asignamos 4 a la var.entero v2</p><p>int mayor //creamos una var. entero llamada mayor</p><p>mayor = (v1 > v2)?v1:v2 </p><p>system.out.println(‚ÄúEl mayor de los dos n√∫meros es ‚Äù + mayor)</p><p>//A mayor en este caso se le asignar√° el valor de v1, ya que se cumple la expresi√≥n. </p>|
|**instanceof [Comprobar si objeto est√° en clase]**|<p>obj instaceof clase</p><p></p><p>Su funci√≥n es comprobar que un objeto (obj) pertenece a una clase en concreto, de forma que este operador devuelve un boolean. </p>|

- **De igualdad o relaciones ‚Üí** utilizados para comparar variables/datos compatibles entre s√≠ (num√©ricos, car√°cter/cadenas o booleanos) de forma que devuelve un boolean (verdadero o falso) seg√∫n se cumpla o no la comparaci√≥n indicada a trav√©s del operador. 



|**Operador**|**Uso (ser√°n true cuando sea cierta la relaci√≥n)**|
| :-: | :-: |
|**== [igual que]**|op1  == op2|
|**!= [distinto que]**|op1  != op2|
|**< [menor que]**|op1 < op2|
|**> [mayor que]**|op1  > op2|
|**<= [menor o igual que]**|op1 <= op2|
|**>= [mayor o igual que]**|op1 >= op2|

- **A nivel de bit ‚Üí** son utilizados cuando necesitamos manipular datos a nivel de bits, como, por ejemplo, habilitar o deshabilitar *flags* (variables que pueden tomar 2 valores, generalmente representados en bits). Dado que en los lenguajes no existe un tipo de ‚Äúun bit‚Äù predefinido, se suelen usar variables de tipo entero (int) para definir flags. 



|**Operador**|**Uso (ser√°n true cuando sea cierta la relaci√≥n)**|
| :-: | :-: |
|**>> [desplaza a la derecha]**|<p>op1  >> op2</p><p></p><p>Desplaza los bits de op1 a la derecha tantas veces como indique op2. Rellena los huecos que quedan con el bit de signo. Esto quiere decir que el bit menos significativo (m√°s a la derecha) se pierde y por la izquierda se a√±ade 0 si el desplazamiento es positivo o bien 1 si el desplazamiento es negativo. </p><p>\*\*Desplazar un bit a la derecha implica dividir entre 2\*\*</p><p></p><p>P.e 2 >> 1 == 1 ‚Üí 0000 0010 ‚Üí 0000 0001</p><p>-2 >> 1 == -1 ‚Üí 1111 1110 ‚Üí 1111 1111</p>|
|**<< [desplaza a la izquierda]**|<p>op1 << op2</p><p></p><p>Desplaza los bits de op1 a la izquierda tantas veces como indique op2. Rellena los huecos que quedan con 0. Esto quiere decir que el bit m√°s significativo (m√°s a la izquierda) se pierde y por la derecha se a√±ade un 0. </p><p>\*\*Desplazar un bit a la izquierda implica multiplicar por 2\*\*</p><p></p><p>P.e 1 << 1 == 2 ‚Üí 0000 0001 ‚Üí 0000 0010</p><p>-3 << 1 == -6 ‚Üí 1111 1101 ‚Üí 1111 1010</p>|
|**>>> [desplaza a la derecha sin signo]**|<p>op1 >>> op2</p><p></p><p>Desplaza los bits de op1 a la derecha tantas veces como indique op2. Rellena los huecos que quedan con 0. Esto √∫ltimo es lo que lo diferencia de >>. </p>|
|**& [and binario]**|<p>op1  & op2</p><p></p><p>Se va realizando el and entre cada bit, dando lugar a un nuevo n√∫mero binario. Cabe destacar que 1 es true y 0 es false.</p><p></p><p>P.e 0101 & 0011 == 0001</p>|
|**| [or binario]**|<p>op1 | op2</p><p></p><p>Se va realizando el or entre cada bit, dando lugar a un nuevo n√∫mero binario. Cabe destacar que 1 es true y 0 es false.</p><p></p><p>P.e 0101 & 0011 == 0111</p>|
|**^ [xor binario]**|<p>op1 ^ op2</p><p></p><p>El funcionamiento de XOR es que s√≥lo ser√° true cuando op1 y op2 sean distintos, de lo contrario ser√° false.</p><p>Se va realizando el xor entre cada bit, dando lugar a un nuevo n√∫mero binario. Cabe destacar que 1 es true y 0 es false.</p><p></p><p>P.e 0101 & 0011 == 0110</p>|
|**~ [complemento]**|<p>~op </p><p></p><p>Equivale a la negaci√≥n pero en binario, de forma que invierte todos los bit que componen al n√∫mero binario. </p><p></p><p>P.e ~0111 == 1000</p>|


- **De asignaci√≥n ‚Üí** modifican el valor de una variable u objeto a otro distinto. 



|**Operador**|**Uso (ser√°n true cuando sea cierta la relaci√≥n)**|
| :-: | :-: |
|**+= [suma]**|op1  = op1 + op2|
|**-= [resta]**|op1 = op1 - op2|
|**\*= [multiplicaci√≥n]**|op1 = op1 \*op2|
|**/= [divisi√≥n]**|op1  = op1 / op2|
|**%=  [modulo]**|op1 = op1 % op2|
|**&= [and]**|op1 = op1 &  op2|
|**|= [or]**|op1 = op1 | op2 |
|**^= [xor]**|op1 = op1 ^ op2|
|**<<= [desplaza a la izquierda]**|op1 = op1 << op2|
|**>>= [desplaza a la derecha]**|op1 = op1 >> op2|
|**>>>= [desplaza a la derecha sin signo]**|op1 = op1 >>> op2|


`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

<a name="_5llknq8aoqsx"></a>**Control de flujos**

- **if-else ‚Üí** los par√©ntesis, es decir la condici√≥n es obligatoria. Adem√°s permite el uso de **break** y **continue** los cuales se explican m√°s abajo. Se pueden anidar los if. Cabe recordar el uso del operador ternario como alternativa (explicado en operadores condicionales arriba). 

Sintaxis: 

`	`**if (condicion) {**
**


**} else if(condicion) {**

**} else {**

**}**

**Nota ‚Üí** Si un if solo tiene en su interior una sentencia (una l√≠nea) no ser√° necesario que indiquemos las {}. 

- **switch ‚Üí** en *expresion* se puede indicar una variable o bien una expresi√≥n que devuelva cualquier tipo; de forma que se analiza las m√∫ltiples posibilidades para esa √∫nica variable o expresi√≥n. Cada caso tendr√° su resultado, pudiendo indicarse cualquier sentencia/s cuando se cumpla dicho caso; si la variable/expresi√≥n no coincide con ninguno de los casos indicados en el switch, se ejecutar√°n las sentencias indicadas en ***default*** (√©ste no es obligatorio ponerlo). 

Cabe destacar el uso de: 

- **Break ‚Üí** permite salir del switch sin que sean evaluadas el resto de opciones. No es necesario usarlo, pero si queremos que encontrada la opci√≥n correcta no se eval√∫en las dem√°s, debemos indicarlo (pues de lo contrario se evaluar√°n varias, es decir aquellas en las que no se haya indicado un break, eso se conoce como cases *anidados*). 

Esta sentencia tambi√©n es utilizada como **control de bucles**, permitiendo terminar de forma abrupta una iteraci√≥n y salir completamente del bucle sin que se ejecuten ninguna de las sentencias ni iteraciones restantes del bucle; no obstante, siempre es m√°s recomendable hacer el bucle de forma que cuando la condici√≥n evaluada sea falsa se salga de ella. 

- **Goto ‚Üí** permite hacer saltos a otras partes de nuestro c√≥digo, y en el caso de un switch permite hacer cosas para posteriormente saltar a otro case. En definitiva permite transferir el control del programa a una etiqueta espec√≠fica en otro lugar del c√≥digo u a otro case en los casos de los switch. Es de las pocas instrucciones que permiten saltar hacia atr√°s o hacia adelante en el flujo de ejecuci√≥n del programa. 

No obstante, su uso no es muy recomendado debido a que puede hacer el c√≥digo m√°s dif√≠cil de entender y mantener, adem√°s de llevar a problemas de l√≥gica y errores dif√≠ciles de detectar. 

P.e: 

`	`**goto etiqueta;** 

`	`**‚Ä¶**

`	`**etiqueta:** 

`	     `**//C√≥digo que se ejecuta despu√©s del goto**

`	`En cuanto a la sintaxis de un switch: 

**switch (expresion/variable) {**

**case valor1:**				En cada case cuando no ponemos nada (solo el valor) es como si fuese un == valor, 

`	`**sentencias1;**			por lo que  si queremos usar otros **operadores de comparaci√≥n** podemos hacerlo. 

`	`**break;**				Cabe destacar que, en vez de usar && u ||, debemos usar ***and*** u ***or***. 

**case < valor2:**				Adem√°s, **se puede pasar m√°s de un valor a evaluar** al switch, p.e switch(var1, var2)

`	`**sentencias2;**

`	`**break;**

**. . .**

**default:**

`	`**sentencias\_default;**

`	`**break;**

**}**

- **while ‚Üí** itera mientras la expresi√≥n que eval√∫a sea verdadera y eval√∫a antes de iterar, es decir ejecuta reiteradamente las sentencias de su interior mientras que la expresi√≥n booleana sea verdadera.

`	`Sintaxis: 

**while (expresion\_booleana/condicion\_de\_permanencia) {**

**. . .**	

`	`**}**

Permite el uso de las sentencias: 

- **Break** (explicado en el switch). 

- **Continue ‚Üí** interrumpe la iteraci√≥n en curso dentro del bucle pero sin salir del bucle por completo, es decir no sale del bucle sino que pasa a la siguiente iteraci√≥n del mismo sin llegar a ejecutar las sentencias siguientes a la sentencia *continue* de la iteraci√≥n actual.  Su uso normal es cuando queremos hacer comprobaciones en el bucle, de forma que completada una comprobaci√≥n espec√≠fica, no es necesario continuar verificando las comprobaciones restantes. 

Esta sentencia a diferencia de break, si que es exclusiva de los bucles, pues si se detecta esta sentencia fuera de un bucle saltar√° un error de compilaci√≥n. 

- **for y foreach‚Üí** permite iterar n veces. Adem√°s permite el uso de **break** y **continue** (Explicado en switch y while respectivamente). 

Sintaxis: 

**for (init\_expr; cond\_expr; update\_expr) {**

`	`**. . .**

**}**

Donde **init\_expr** contiene un expresi√≥n de inicializaci√≥n del bucle, es decir el valor inicial desde el que se empieza a iterar (podemos declarar e inicializar dicha ‚Äúvariable‚Äù a pelo ah√≠ en la cabecera o inicializarla antes y simplemente nombrarla en la cabecera); **cond\_expr** contiene la expresi√≥n o condici√≥n de permanencia en el bucle, es decir en el momento en que se deja de cumplir, se deja de iterar; **update\_exp** contiene la expresi√≥n de actualizaci√≥n, es decir el nuevo valor del iterador en cada vuelta (se actualiza el valor de init\_expr, normalmente se suele usar i++ o i --). 

// Se puede utilizar con todas aquellas clases que implementen la interfaz **IEnumerator** 

**foreach (tipodedato vartipodedato in nombrearray)** 

**{**

`      `**...**

**}**

- **do-while ‚Üí** itera mientras la expresi√≥n que eval√∫a sea verdadera y eval√∫a despu√©s de iterar, esto quiere decir que siempre se ejecuta al menos una vez. Adem√°s permite el uso de **break** y **continue** (Explicado en switch y while respectivamente). 

Sintaxis: 

**do {**

**} while (expresion\_booleana/condicion\_de\_permanencia)**

**\*\*Nota\*\* ‚Üí** Cabe destacar que el uso de **return** implica salir de la funci√≥n, rompiendo un bucle si se encuentra en √©l y devolviendo en valor que se indique a continuaci√≥n del *return*. 

-----

<a name="_cn98v26mnsw"></a>**MODIFICADORES DE ACCESO Y/O PALABRAS RESERVADAS**

Es importante tener en cuenta que los modificadores de acceso s√≥lo se aplican a los miembros de una clase (m√©todos/atributos/propiedades) y no a la clase en s√≠ misma. Pues la clase en s√≠ misma puede ser *p√∫blica o interna* con independencia de los modificadores de acceso que se apliquen a sus miembros. 

- **public ‚Üí** indica disponibilidad global del m√©todo/atributo/propiedad desde cualquier punto del programa, es un modificador de acceso que determina desde d√≥nde y qui√©n puede acceder a √©l. [aplicable tambi√©n a una clase en s√≠ misma] 
**


- **private ‚Üí** se trata de un modificador de acceso que permite que solo se pueda acceder al m√©todo/atributo/propiedad desde la propia clase en la que se est√° declarando. Los campos|atributos, propiedades y m√©todos son private por defecto, a menos que se indique lo contrario utilizando otro modificador de acceso. 

- **protected ‚Üí** se trata de un modificador de acceso que hace que los miembros de una clase (m√©todos/atributos) s√≥lo sean accesibles desde dentro de la misma clase o desde clases derivadas de ella. 

- **internal ‚Üí** se trata de un modificador de acceso que hace que los miembros de una clase (m√©todos/atributos/propiedades) s√≥lo sean accesibles desde dentro del mismo ensamblado (es decir, desde un mismo archivo DLL o EXE, aunque un ensamblado puede contener uno o m√°s archivos de este tipo). [aplicable tambi√©n a una clase en s√≠ misma]

Las clases, por defecto son internas, a menos que se indique lo contrario mediante el uso de otro modificador de acceso. 

\*\* Se puede utilizar **protected internal** lo cual indica que los miembros de una clase sean accesibles desde dentro del mismo ensamblado o desde clases derivadas de ella. 

- **final ‚Üí** permite establecer un m√©todo, clase o variable como final (ver explicaci√≥n para cada uno en su apartado correspondiente). 

- **static ‚Üí** cuando usamos esta palabra al declarar un campo / propiedad / m√©todo lo que estamos determinando es que dicho elemento pertenece √∫nica y exclusivamente a la clase en la que se encuentra. Esto quiere decir que cuando queramos utilizarlo no debemos hacerlo a trav√©s de la instancia de la clase, es decir a trav√©s de un objeto, sino que debemos hacerlo a trav√©s de la misma clase.

Por lo tanto, todo aquello que sea est√°tico puede ser utilizado sin que exista instancia alguna y nunca se podr√° usar a trav√©s de ning√∫n objeto de dicha clase. Cabe destacar que tambi√©n se puede determinar una clase como est√°tica, en cuyo caso TODOS los elementos que se declaren dentro de √©sta tambi√©n deber√°n ser est√°ticos, adem√°s como es de esperarse una clase est√°tica no podr√° ser instanciada (un ejemplo de este tipo de clase es Math). . 

- **new ‚Üí** Permite la creaci√≥n de un nuevo objeto (tipo de datos complejo), es decir permite instanciar una clase. 

-----

<a name="_mf1hjp7cmzsl"></a>**CLASES Y OBJETOS**

Una clase suele estar representada por la siguiente estructura: 

**modificadoresdeacceso class NombreClase{** 

`	`**// Definici√≥n de *propiedades/atributos* (caracter√≠sticas del elemento que describimos con la clase)**

`	`**// Definici√≥n de los *m√©todos* (comportamiento y funcionalidades del elemento)**

**}** 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

Existen **cuatro tipos de clases** que son: 

- **Clase est√°tica ‚Üí** Para determinar una clase como est√°tica debemos de indicar tras su modificador de acceso la palabra reservada **static** (explicaci√≥n en apartado palabras reservadas) y antes de la palabra *class*. Como vimos anteriormente, este tipo de clase no puede ser instanciada y s√≥lo puede contener miembros est√°ticos, lo cual quiere decir que se puede usar dicha clase directamente desde la clase y en ning√∫n caso desde un objeto creado de dicha clase. 

Un ejemplo de este tipo de clase es Math.

`	`**modificadorDeAcceso static class nombreDeLaClase {}**

- **Clase abstracta ‚Üí** clase com√∫n que posee atributos y m√©todos, y que tiene **al menos un m√©todo abstracto** (definido pero no implementado, es decir especificando solo su nombre, tipo de retorno y argumentos de entrada) y **no admite m√©todos est√°ticos**. Cabe destacar que pueden haber constructores; no obstante, debemos tener en cuenta que solo servir√°n como ‚Äúplantilla‚Äù para las clases hijas, ya que NO se pueden crear objetos de una clase abstracta, por lo que de forma directa dicho constructor no ser√° utilizado para crear un objeto de la clase abstracta, sino para ser heredado; es por ello que dichos constructores deber√°n de ser creados como *protected.* 

En cualquier caso **TODOS los m√©todos abstractos deben ser implementados por las clases hijas** de la clase abstracta que los define (haciendo sobrescritura a trav√©s de @Override). 

Las clases abstractas **no se instancian** (no se puede usar para crear un objeto, para crear uno deberemos hacerlo a trav√©s de sus clases hijas), sino que se emplean como bases para la herencia, es decir para otras clases llamadas **clases  concretas o reales**.  

Con la abstracci√≥n captamos los comportamientos (m√©todos) y atributos de un objeto, ocultando detalles y mostrando solo informaci√≥n esencial.   

Declarar variables privadas en una clase abstracta es absurdo, ya que nunca se utilizar√°n; por lo que los niveles de visualizaci√≥n deben ser **public** o **protected**.  

En cuanto a la sintaxis para declarar una clase como abstracta a√±adimos **abstract** antes de la palabra class. En el momento en que se declare como tal la clase, Netbeans nos mostrar√° el fichero \_\_\_.java con las figuras en gris en vez de en colores, as√≠ sabremos que la clase es abstracta. 

Para la creaci√≥n de m√©todos abstractos, tambi√©n es necesario usar la palabra **abstract** antes de indicar el tipo de retorno. 

Ejemplo: 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.003.png)

La clase Figura es una clase abstracta porque no tiene sentido calcular su √°rea, ya que cada figura tiene una forma de calcularla, es decir no tiene sentido calcular el √°rea de Figura pero s√≠ el de sus hijos (c√≠rculo y  cuadrado). 

Vemos que cada hija tiene un atributo propio, radio en el caso de c√≠rculo y lado en el caso del cuadrado. Adem√°s el m√©todo abstracto de Figura es implementado por c√≠rculo y cuadrado de formas diferentes (son distintas f√≥rmulas). 










- **Clase final ‚Üí** aquellas clases que acaban con la cadena de herencia, es decir no se puede heredar m√°s all√° de una clase final. Para establecer una clase como tal se debe utilizar la palabra clave ***final***. 

- **Clase p√∫blica ‚Üí** se puede acceder a ellas desde otras clases o mediante herencia. Son accesibles en el mismo paquete donde se declaran; o bien desde otros paquetes donde previamente tienen que ser importados. 

Al igual que los tipos de m√©todos, las clases pueden ser no ***public, private*** (s√≥lo puede ser accedida desde la misma clase y nada m√°s)*** o ***protected*** (visible en la clase donde se define y en cualquiera de sus subclases). 

- **Clase sincronizable ‚Üí** este modificador indica que los m√©todos definidos en la clase est√°n sincronizados, es decir que no se puede acceder desde diferentes hilos a la vez, y el sistema se encarga de colocar los flags para evitarlo. Esto permite modificar las mismas variables desde diferentes hilos sin sobrescribirlas. 

- **Clases anidadas ([Ejemplos](https://www.tutorialesprogramacionya.com/javaya/detalleconcepto.php?codigo=170)) ‚Üí** m√©todo de agrupaci√≥n l√≥gica que solo se usa cuando una clase s√≥lo es √∫til para otra clase, por lo que es l√≥gico incrustarse en esa clase. Gracias a esta pr√°ctica se a√±ade **encapsulaci√≥n** (sean A y B dos clases donde B necesita acceder a un miembro privado de A. Al ocultar B en A, los miembros de A pueden declararse privados y accesibles para B. Adem√°s B en s√≠ mismo puede ocultarse del mundo exterior).  

Una clase anidada tiene acceso a los miembros (incluidos los privados) de la clase en la que est√° anidada, y de igual forma la clase envolvente puede acceder a los de la clase anidada. As√≠ pues, decimos que el alcance de una clase anidada est√° limitado por el alcance de su clase envolvente), ya que la clase anidada no deja de ser un miembro de la clase envolvente y como miembro, dicha clase anidada puede ser declarada *private, public, protected* o *private*. 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.004.png)![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.005.png)

- **Est√°tica ‚Üí** en el caso de las clases internas, no podemos crear un objeto de clase interno sin que exista previamente creado un objeto de clase externo. No obstante, cuando se trata de una clase anidada est√°tica, **sin que exista un objeto de clase externa creado, puede haber un objeto de clase anidada est√°tica**, es decir el objeto de una clase anidada est√°tica no est√° fuertemente asociado con el objeto de la clase externa. 

Sin embargo, una clase anidada est√°tica **no puede referirse directamente a variables de instancia o m√©todos definidos en su clase envolvente** (a variables/m√©todos est√°ticos s√≠), sino que debe usarlos a trav√©s de una referencia de objeto, es decir habiendo sido creado previamente un objeto de la clase externa.  

Este tipo de clase **si puede declarar miembros est√°ticos**, por lo que s√≠ puede declarar main() y por ende  est√° clase se puede invocar directamente desde el s√≠mbolo(terminal) del sistema. 

En cuanto a la sintaxis se crea un objeto de esta clase: 

**claseenvolvente.claseanidada nombreobjtinterna = new claseexterna.claseanidada();** 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.006.png)

- **Internas (no est√°ticas/InnerClass) ‚Üí** como hemos indicado antes, en el caso de este tipo de clases, no podemos crear un objeto de clase interno sin que exista previamente creado un objeto de clase externo; es decir, el objeto de clase interno siempre est√° asociado con el objeto de clase externo. Es por esto √∫ltimo que para crear una clase interna, primero debe crearse una instancia de la clase externa, luego dentro de dicho objeto creado, se debe crear el objeto interno mediante la siguiente sintaxis: 

`	`**claseexterna.claseinterna nombreobjtinterno = nombreobjexterno.new claseinterna();**

Sin embargo, **una clase interna s√≠ puede acceder directamente a los miembros est√°ticos y no est√°ticos de la clase externa**, es decir sin tener que hacer referencia a ning√∫n objeto externo.  

Dentro de esta **no** ser√° posible **declarar miembros est√°ticos** y debido a ello no podemos declarar el m√©todo main(), por lo que la clase interna no se puede invocar directamente desde el s√≠mbolo del sistema. 

- **Locales ([Ejemplos](https://barcelonageeks.com/clase-interna-local-en-java/)) ‚Üí** clases internas que se definen dentro de un bloque (cuerpo de un m√©todo, un bucle for o un if entre otros, es decir conjunto de cero o m√°s declaraciones de llaves equilibradas/iguales) y su alcance est√° restringido a dicho bloque, es decir solo se pueden usar dentro de √©l. Por lo que decimos que √©stas no son miembros de ninguna clase envolvente, sino que pertenecen al bloque en el que est√°n definidas. Esto significa que **no puede tener ning√∫n modificador de acceso asociado** a ellas (private, public, static, protected), aunque s√≠ que pueden marcarse como finales o abstractos. Estas clases deben **instanciarse en el bloque en el que est√°n definidas.** ![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.007.png)

Estas clases pueden **acceder a las variables** o par√°metros del bloque que las encierra (p.e o  en el ejemplo); y podr√° acceder a las variables locales (p.e local en el ejemplo), solo si dichas variables/par√°metros se declaran como **finales** o son **efectivamente finales**. [recordemos que una **variable efectivamente final** es aquella cuyo valor no cambia una vez inicializada].

Cuando se **compila** un programa que contiene una clase interna local, el compilador genera dos archivos **.class**, uno para la clase externa (clase exterior) y otro para la clase interna que tiene la referencia a la externa (exterior$1interior.clase). . 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.008.png)

- **An√≥nimas ([ejemplos](http://programmingbabel.blogspot.com/2017/09/clases-anonimas-java-anonymous-classes.html)) ‚Üí** clase interna sin nombre para la que se crea un √∫nico objeto, √©sta puede ser √∫til al crear una instancia de un objeto con ciertos ‚Äúextras‚Äù como anular m√©todos de una clase o interfaz sin tener que subclasificar una clase. As√≠ pues, concluimos que para crear una clase an√≥nima es necesario haber definido una interfaz, una clase o una clase abstracta, ya que la clase an√≥nima lo que har√° ser√° implementar la interfaz definida o sobreescribir los m√©todos definidos.  

Se consideran una soluci√≥n r√°pida para implementar una clase que **se va a utilizar una vez** y de forma inmediata, es decir permite **declarar e instanciar una clase al mismo tiempo** (clase an√≥nima).

La clase an√≥nima puede implementar cualquier cantidad de interfaces, pero la clase an√≥nima **solo puede implementar una interfaz a la vez**; la clase regular puede extender una clase e implementar cualquier cantidad de interfaces simult√°neamente, pero la an√≥nima puede extender una clase o implementar una interfaz **pero no ambas a la vez**; la clase an√≥nima **no tienen ning√∫n constructor porque no tiene nombre**. 

En cuanto al **acceso a variables** esta clase tiene acceso a los miembros de su clase envolvente, pero no puede acceder a variables locales en su √°mbito adjunto que no est√©n declaradas como finales o efectivamente finales. Por otro lado, al igual que todas las clases anidadas internas no se puede declarar inicializadores est√°ticos o interfaces de miembros de una clase an√≥nima y √©sta puede tener miembros est√°ticos siempre que sean variables constantes. As√≠ pues, decimos que las clases an√≥nimas pueden declarar: 

- Campos
- M√©todos adicionales. 
- Inicializadores de instancia. 
- Clases locales. 

En cuanto a su sintaxis es como la invocaci√≥n de un constructor, con la diferencia de que hay una **definici√≥n de clase contenida en un bloque de c√≥digo ({})**, pudiendo estar la clase an√≥nima definida dentro de un m√©todo o fuera.  

**Saludo frenchGreeting = new Saludo() {}**  

//Saludo ser√≠a el tipo de dato de cualquier superclase o interfaz que vamos a extender o implementar

//frenchGreeting ser√≠a el nombre de una variable que va a almacenar nuestra implementaci√≥n 

//Saludo() el nombre de la superclase/interfaz a extender/implementar como un constructor sin argumentos 

//Los corchetes contendr√°n dentro la implementaci√≥n 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

<a name="_5ayry0bhbr42"></a><a name="_75x49daoes57"></a>**Constructor**

*M√©todo especial* que se invoca cada vez que se genera un objeto de la clase a la que √©l pertenece (a trav√©s de √©l se podr√° dar valores iniciales a los atributos que tiene ese objeto). No obstante, no funciona exactamente como un m√©todo, sino que tiene un comportamiento distinto. 

C# genera un m√©todo constructor **por defecto** para cada clase; sin embargo nosotros tambi√©n podemos hacerlo. Dependiendo de las necesidades que tenga cada proyecto, **una clase puede tener uno o varios constructores**.  Cada m√©todo constructor debe cumplir con las siguientes **caracter√≠sticas**: 

- Tener el mismo nombre de la clase a la que pertenece. 
- Deben ser declarados como p√∫blicos para que puedan ser invocados desde fuera de la clase, aunque no se utiliza la palabra reservada void en la sintaxis (a pesar de que el constructor no devuelve ning√∫n valor). 
- Suele ser el primer bloque de c√≥digo que se construye cuando se est√° haciendo la clase. 
- Puede tener o no par√°metros, depende de lo que requiera el proyecto. 
- Solo se ejecuta cuando es invocado para crear una instancia de un objeto, es decir siempre debe utilizarse precedido por la palabra reservada new. 

**Tipos de constructores:** 

- **Por defecto ‚Üí** es el que asume el compilador por defecto cuando el programador no lo declara de manera expl√≠cita. Dado que implica no inicializar los atributos, √©stos toman los valores predeterminados dependiendo del tipo de datos que se haya declarado. **P.e public Persona() {**

- **Con par√°metros ‚Üí** lo crea de forma expl√≠cita el programador respetando siempre las caracter√≠sticas que establece C# y permite dar valores espec√≠ficos a los atributos de un objeto creado. **P.e public Persona(String nombre, String apellidos, int edad) {**

Si creamos un constructor parametrizado  nunca se va a crear autom√°ticamente el constructor por defecto, por lo que ser√° necesario que lo hagamos nosotros.  


**\*\*Nota () ‚Üí** Cuando se crea una clase hija, √©sta hereda todos los miembros (m√©todos/atributos) de la clase padre/base, incluyendo los constructores. Por lo que si en una clase hijo no definimos expl√≠citamente un constructor, se utiliza autom√°ticamente el constructor predeterminado (sin par√°metros) de la clase base. Sin embargo, si se define un constructor en la clase hija, este puede requerir que se llame a un constructor de la clase base para inicializar los miembros heredados de la clase base. Es en estos casos donde entra en juego la palabra **base** para inicializar los miembros heredados de la clase base. P.e

**public class DerivedClass : BaseClass**			la clase hija llama al constructor predeterminado de la clase base, de forma que se 

**{**						asegura que los miembros heredados de la clase base se inicializan correctamente 

`	`**public DerivedClass() : base()**			antes de ejecutar el c√≥digo adicional de inicializaci√≥n en el constructor de la c. hija. 

`	`**{**

`	`**//C√≥digo adicional de inicializaci√≥n** 

**}**

**}**

**public class DerivedClass : BaseClass**			En este caso ocurre lo mismo pero utilizando un constructor con par√°metros. Cabe 

**{**						destacar que si quiero incluir otro par√°metro m√°s al constructor de la clase derivada

`	`**public DerivedClass(int Value) : base(value)**	lo puedo hacer, simplemente a la clase padre solo debo mandar los del constructor 

**{**					del padre a trav√©s de base. 

**//C√≥digo adicional de inicializaci√≥n** 

**}**

**}**



Adem√°s de con constructores, la palabra **base** nos permite inicializar atributos de la clase padre y sobreescribir m√©todos de la clase padre para luego invocarlos con *base*. En este caso a diferencia de los constructores, deberemos de indicar el nombre del m√©todo/atributo, **base.nombremetodo\_atribut()**; para poder invocarlo. Cabe destacar **(!!!)** que solo se permite el acceso a la clase base en un constructor, m√©todo de instancia y en un descriptor de acceso de propiedad de instancia (getters y setter, es decir accessors), en cualquier otro caso dar√° error. 

Si queremos hacer esto mismo, pero en vez de tomando un constructor de la clase padre, tomando otro de los constructores de la propia clase entonces usamos **this(parametros del constructor al que se invoca).** 

**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

<a name="_p5z354akc6zj"></a>**M√©todos || funciones**

Son las funciones que se pueden llamar en el interior de una clase o por otras clases y que permite al objeto la capacidad para cambiar su estado. La sintaxis es:

`	`**[ModificadoresAcceso] TipoRetorno nombreM√©todo ([lista\_de\_argumentos]) [excepciones]**

**{**

`		`**BloqueDeC√≥digo**

`		`**return (en caso de que retorne alg√∫n valor)**

**}** 

- *lista\_de\_argumentos ‚Üí* es opcional, se utiliza para enviar informaci√≥n al cuerpo del m√©todo. Es literalmente lo mismo que los par√°metros cuando creamos funciones/procedimientos en otros lenguajes. Los valores de dichos par√°metros, si los hubiese, se pasan al usar el m√©todo. Al declarar una funci√≥n la lista de argumentos deben de formarse por el tipo de dato y el nombre del argumento tal y como se vaya a usar dentro de la definici√≥n de la funci√≥n.
- *Tipo de retorno ‚Üí* representa el tipo de datos devueltos despu√©s de ejecutar la tarea, es decir el tipo de dato que usamos tras ***return***. Si no se devuelve nada, debemos poner **void**.
- *Modificadores de Acceso ‚Üí* En ellos ponemos si el m√©todo es p√∫blico o privado (*public/private*), y adem√°s el tipo de m√©todo que es en caso de que haya que especificarlo (p.e si es *static*).

Existen distintos **tipos de m√©todos**: 

- **M√©todos private ‚Üí** aquellos que solo se pueden utilizar dentro de la clase. Los m√©todos, por defecto son private, a menos que se indique lo contrario mediante el uso de otro modificador de acceso. 
- **M√©todos public ‚Üí** aquellos que pueden ser invocados desde el exterior de la clase. 
- **M√©todos protected ‚Üí** aquellos que pueden ser empleados por la clase donde son definidos y en las clases derivadas (herederas) de ella. 
- **M√©todos internal ‚Üí** aquellos que pueden ser accesibles y visibles desde el mismo ensamblado en el que se encuentra definido. 
- **M√©todo final ‚Üí** aquellos que no pueden ser anulados ni modificados, pues si se hereda de una clase y la clase heredera intenta sobrescribir un m√©todo declarado como final, se producir√° un error de compilaci√≥n.

**class A** 

**{**

`    `**final void m1()** 

`    `**{**

`        `**System.out.println("Este es un m√©todo final.");**

`    `**}**

**}**

**class B extends A** 

**{**

`    `**void m1()**

`    `**{** 

`        `**// COMPILACI√ìN-ERROR!** 

`        `**System.out.println("Ilegal!");**

`    `**}**

**}**

- **M√©todos est√°ticos o de clase ‚Üí** son aquellos que se caracterizan porque pueden ser llamados sin instanciar ning√∫n objeto de la clase (ya que si intentamos utilizar un m√©todo est√°tico a trav√©s del nombre del objeto creado, veremos que hay un error). Sabemos que un m√©todo es est√°tico porque va precedido por la palabra **static**.

Estos m√©todos solo pueden acceder a variables est√°ticas o de clase, y no pueden acceder a variables de instancia a menos que se cree un objeto y se acceda a las variables de instancia a trav√©s de ese objeto.  

**nombreDeLaClase.nombreDelMetodo();**

**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

<a name="_151nm1srdbn"></a>**Sobrecarga de m√©todos**

Se trata de una forma de **polimorfismo est√°tico|param√©trico** y consiste en dar el mismo nombre pero diferentes par√°metros (n¬∫ y nombres), de forma que cada m√©todo puede realizar una tarea diferente pero compartiendo el mismo nombre. La importancia radica en poder relacionar los m√©todos a trav√©s de un nombre com√∫n, aunque cumplan distintas funciones manteniendo la calidad en el c√≥digo y reutilizando funciones sin extender la cantidad de l√≠neas de c√≥digo. 

**Nota \*\* ‚Üí** en ning√∫n caso, podremos aplicar la sobrecarga si cambiamos el tipo de retorno, esto quiere decir que aunque se pueda cambiar el n¬∫ y/o tipo de par√°metros, NO podemos cambiar el tipo de retorno del m√©todo. 

P.e: 

`	`**public int Sum(int a, int b) {**

`	`**return int.Parse(a) + int.Parse(b);** 

**}**

**public int Sum(int[] numbers)**

**{**

`	`**int result = 0;** 

**int i = 0**

**while (i < numbers.Length)** 

**{**

`	`**result += numbers[i];** 

`	`**i++;** 

**}**

**}**

<a name="_9p43ycfilmvx"></a>**Sobreescribir m√©todos** 

Se trata de una forma de **polimorfismo din√°mico|ad hoc** y consiste en que una clase hija cambie la implementaci√≥n de un m√©todo que ha sido heredado de la clase padre. De forma que la subclase anula la implementaci√≥n de la superclase proporcionando un m√©todo con la misma forma (mismo nombre, n¬∫ y tipo de par√°metros, as√≠ como mismo dato de retorno), en caso de que queramos modificarlo por completo; o bien utilizarlo y simplemente ampliar dicha funcionalidad. 

Para poder llevar a cabo esta pr√°ctica debemos de incluir en el m√©todo de la clase padre la palabra reservada ***virtual*** tras el modificador de acceso del m√©todo y antes de su tipo de dato de retorno; y por otro lado incluir en el m√©todo de la clase hija la palabra reservada ***override*** tras el modificador de acceso del m√©todo y antes de su tipo de dato de retorno. 

P.e (anular el del padre dando lugar al m√©todo con la misma forma pero distinta funcionalidad) 

`	`**public class A** 

`	`**{**

`		`**public virtual string Hi()**

`		`**{**

`	`**return ‚ÄúHola soy A‚Äù;**

**}**

**}**

**public class B : A**

**{**

`	`**public override string Hi()**

`	`**{**

`	`**return ‚ÄúHola soy B‚Äù;** 

**}**

**}**

(si en vez de anular la implementaci√≥n realizada por el padre, queremos ampliarla podemos hacerlo usando **base,** que se explica en el apartado de constructores)

`	`**public class A** 

`	`**{**

`		`**public virtual string Hi()**

`		`**{**

`	`**return ‚ÄúHola soy A‚Äù;**

**}**

**}**

**public class B : A**

**{**

`	`**public override string Hi()**

`	`**{**

`	`**return base.Hi() +  ‚ÄúHola soy B‚Äù;** 

**}**

**}**


**Sobrecarga vs Sobreescritura (uso)**

La sobrecarga de m√©todos es √∫til cuando se desea proporcionar una funcionalidad similar pero con diferentes par√°metros. Por ejemplo, se puede tener un m√©todo *CalcularArea* que acepte un par√°metro de radio para calcular el √°rea de un c√≠rculo y otro m√©todo *CalcularArea* que acepte dos par√°metros para calcular el √°rea de un rect√°ngulo. La sobrecarga de m√©todos permite que el mismo nombre de m√©todo se utilice para diferentes prop√≥sitos.

La sobrescritura de m√©todos, por otro lado, se utiliza cuando se desea modificar el comportamiento de un m√©todo en una subclase. Por ejemplo, se puede tener una clase Animal con un m√©todo Sonido que devuelve un sonido gen√©rico para todos los animales. Si se desea que los perros hagan un sonido diferente al de los gatos, se puede crear una subclase Perro que sobreescriba el m√©todo Sonido para devolver el ladrido de un perro en lugar de un sonido gen√©rico.

En resumen, la sobrecarga de m√©todos se utiliza para proporcionar diferentes formas de hacer lo mismo con diferentes par√°metros, mientras que la sobrescritura de m√©todos se utiliza para modificar el comportamiento de un m√©todo en una subclase.

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

<a name="_uod0bqfmcok0"></a>**Variables || atributos || campos**

`	`**[ModificadoresAcceso] TipodeDato nombreDeLaVariable = ValorDeLaVariable;** 


Los campos, por defecto son private, a menos que se indique lo contrario mediante el uso de otro modificador de acceso. Por otro lado, se recomienda empezar el nombre de los campos privados con un **\_** para as√≠ saberlos diferenciar de los par√°metros recibidos en los constructores (aunque recordemos que siempre ser√° mejor pr√°ctica utilizar el this. ); normalmente por convenci√≥n se considera que los campos que empiezan con un **gui√≥n bajo** son privados. 

- **Variables est√°ticas o de clase ‚Üí** aquellas variables espec√≠ficas de cada clase y no para cada objeto. √âstas se usan para definir constantes que son comunes a todos los objetos en una clase o variables que solo son significativas para el conjunto de la clase. Sabemos que una variable es est√°tica porque va precedida por la palabra **static**. 

Dado que se vincula con la clase y no con el objeto, en vez de usar *this* (para usarla desde dentro de la clase) o el nombre del objeto (para usarla desde fuera de la clase), debemos usar directamente el nombre de la clase (**nombredelaclase.varestatica**). Cabe destacar que **se puede modificar** el contenido de una variable est√°tica, en cuyo caso dicho valor se modificar√° para toda la clase y todas las instancias que se creen de ella. Esto √∫ltimo es √∫til si por ejemplo queremos tener un contador de cu√°ntas instancias se hacen de una clase.  

Lo importante es que las variables est√°ticas siempre se inicializan antes que cualquier objeto de la clase. 

P.e 

**public class People**

` `**{**

`            `**public static int Count = 0;**

`            `**public string Name { get; set; }**

`            `**public int Age { get; set; }**

`            `**public People()**

`            `**{**

`                `**Count++;**		// Esto har√° que cada vez que se use el constructor, es decir cada vez que se instancia la clase 

`            `**}**			// la variable Count incremente, y dado que √©sta variable/campo es est√°tica lo har√° de forma 
**
`			`// global para la clase,. 

`            `**public static string GetCount()**

`            `**{**

`                `**return $"Esta clase se ha utilizado {Count} veces";**

`            `**}**

` `**}**


- **Variables de instancia ‚Üí** Son aquellas que deben inicializarse tras la creaci√≥n de una clase. Se declaran dentro de la clase y fuera del cuerpo de los m√©todos. Son del tipo global y pueden ser utilizadas por cualquier m√©todo no est√°tico que las llame. 

- **Variables efectivamente finales ([ejemplos](https://javadesdecero.es/palabra-clave/final/)) ‚Üí** aquellas que tras ser inicializadas, no var√≠an su valor, se diferencian de las variables normales porque no se puede reasignar su valor (pues en tal caso salta error de compilaci√≥n). Para declarar una **variable final** basta con poner la palabra ***final*** antes del tipo de dato, su inicializaci√≥n se puede producir luego. Se diferencia de las variables **const** de C++, porque no tiene que inicializarse si o si al se declarada, sino que puede asignarse el valor m√°s adelante, pero **solo una vez**. 

**OJO**, podemos declarar **variables finales de referencia**, que son aquellas que al declararlas no las inicializamos (no le damos valor) y que posteriormente cambiamos el estado interno del objeto se√±alado por esa variable de referencia (**cuidado, no confundir con una reasignaci√≥n**) como se indica en el siguiente ejemplo: 

//Programa Java para demostrar

// la variable final de referencia

**class JDC {**

`    `**public static void main(String[] args) {**
**
`        `//una variable final de referencia

`        `**final StringBuilder cadena=new StringBuilder("Java");**

`        `**System.out.println(cadena);**
**
`        `//cambiando estado interno de referencia del objeto

`        `//por variable de referencia final 'cadena'

`        `**cadena.append("desdeCero");**

`        `**System.out.println(cadena);**

`    `**}**

**}**

**This ‚Üí** permite hacer referencia al objeto actual de la clase en la que nos encontramos, es decir, a una instancia concreta de la clase y nos sirve para usar los m√©todos y atributos de esa clase desde cualquier punto del c√≥digo que define la clase. Equivale al *self.* de python. Por eso suele verse delante de los atributos en los constructores y en los getters/setters ya que lo normal es que los par√°metros tengan los mismos nombres que los atributos de la clase, de forma que al poner el this, podemos diferenciar entre los par√°metros y los atributos|propiedades de la propia clase donde se usan. Su sintaxis es **this.nombreatributo\_metodo;** 

En conclusi√≥n, al utilizar *this* dentro de una clase, podemos acceder a cualquier miembro de la misma, raz√≥n por la cual solo tiene sentido utilizarlo dentro del contexto de una instancia de objeto. Cabe destacar, que al igual que como ocurre con base, no se puede usar this en un m√©todo est√°tico. 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

<a name="_36besu8vb9bv"></a>**Propiedades** 

Son similares a los atributos|campos de una clase, con la diferencia de que en este caso cuentan con ***accessors*** encargados de permitir acceder, leer y/o escribir sobre ellos. Es decir, una propiedad es una forma de exponer los campos de una clase para que puedan ser accedidos por c√≥digo externo, proporcionando una interfaz m√°s segura y conveniente que los campos de la clase, al controlar el acceso a los mismos y validar los valores que se asignan.  

De esta forma, las propiedades pueden ser de **solo lectura (get), de escritura (set) o de ambas (set y get).** 

Las propiedades tambi√©n pueden tener un modificador de acceso como public, private, internal o protected, para controlar el acceso a ella desde fuera de la clase, al igual que sus accessors (**descriptores de acceso, get y set**). En cuanto a su sintaxis (parece un m√©todo pero sin el uso de ()) : 

`	`**[modificadoracceso] tipodedato nombrePropiedad {** 

**[modificadoracceso] get{}**

**[modificadoracceso] set{}** 

**}**

**\*\*** Otra pr√°ctica es que al declarar una propiedad pongamos en su cuerpo **{get; set;}**, es decir indicando los descriptores de acceso vac√≠os, de forma que no realizan ninguna acci√≥n adicional a obtener y/o establecer el valor de la propiedad. En este caso lo que hace el compilador de  C# es que crea de forma autom√°tica la funcionalidad b√°sica de dichos descriptores de acceso, es decir, devolver el valor del campo de respaldo (con el que est√° asociado la propiedad) y/o modificarlo. Si por alg√∫n motivo, el campo no ha sido inicializado, su valor predeterminado depender√° del tipo de dato de la propiedad. P.e si se trata de una propiedad de tipo int, el valor predeterminado ser√° 0.

As√≠ pues, podemos decir que esta **forma abreviada** se utiliza cuando queremos que la propiedad haga de campo, es decir cuando no queremos declarar de manera expl√≠cita un campo.  Se usa mucho en **interfaces** ya que en ellas no usamos campos sino solo propiedades. 

**\*\*** Podemos **dar valor a las propiedades directamente en el momento de instanciar la clase**, como se podr√° ver en el ejemplo de a continuaci√≥n. 

**\*\*** Si no estamos controlando que la propiedad siempre adquiera un valor porque hemos usado la forma abreviada {get; set;} entonces en el tipo de dato de la propiedad debemos indicar un **?** como p.e ‚Üí **public string? Name { get; set; }** esto har√° que si no damos valor a Name en el momento de instanciar la clase, Name valga ‚Äú‚Äù. 

**\*\*** Por convenci√≥n solemos indicar las propiedades p√∫blicas con **la primera letra en may√∫scula (y prevo \_ en caso de que se trate de una propiedad privada)**, de forma que se pueda diferenciar respecto al campo con el que se asocia gracias a esa letra en may√∫scula. Adem√°s, no tiene porque ser del mismo tipo que el campo al que vamos a permitir el acceso, como veremos en el siguiente ejemplo: 

**class Persona**

**{**

`	`**private string nombre;** 

`	`**private int edad;** 

`	`**public string Nombre {get; set;}**
**


`	`**public string Edad**

**{**

`	`**get**		//Su funci√≥n siempre ser√° devolver el valor de la propiedad 

`	`**{**

`		`**return total.ToString();** 

**}**

**set**			//Su funci√≥n siempre ser√° permitir la modificaci√≥n de la propiedad, por defecto siempre

**{**			//que se use se pasar√° *value* que es el valor nuevo con el que queremos modificarlo. 

`	`**if (value < 0)** 

`		`**value = 0;** 

`	`**total = value;** 

**}**

**}**

**}** 

//Uso de la clase Persona 

**Persona persona1 = new Persona();** 

//Usando accessor set de la clase Persona1

**persona1.Nombre = ‚ÄúJuan‚Äù;** 

**persona1.Edad = 30;** 

//Usando accessor get de la clase Persona1

**Console.WriteLine(‚ÄúNombre: ‚Äú + persona1.Nombre);**

**Console.WriteLine(‚ÄúEdad: ‚Äú + persona1.Edad);**

//Tambi√©n es posible inicializar las propiedades en el momento en que se crea un objeto de clase

**Persona persona2 = new Persona() {**

`	`**Nombre = ‚ÄúPepo‚Äù,** 

`	`**Edad = 30**

**}**

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

Para **instanciar una clase** o lo que es lo mismo, **crear un objeto** en base a una clase se debe seguir la siguiente sintaxis: 

`	`**NombreDeLaClase NombreQueQueremosPonerAlObjeto = new ConstructorDeLaClase(ValoresDeLosPar√°metros)**

**Nota ‚Üí**  no ser√° posible instanciar una clase est√°tica. 

**Nota ‚Üí** se pueden inicializar las propiedades en el momento en que se instancia un objeto, tal y como se ve en el ejemplo anterior. 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

<a name="_k43y4h8g2bu9"></a>**Herencia** 

Caracter√≠stica que permite crear una clase tomando como base a otra clase ya existente, lo que permite reutilizar c√≥digo y especializarlo. P.e a partir de la clase Persona se puede crear otras clases m√°s especializadas a trav√©s de la herencia que respondan a las necesidades de cada tipo de persona, como un desarrollador, m√©dicos, etc. 

Cuando una clase hereda de otra clase**, la heredera recibir√° TODOS los atributos (estado) y m√©todos (comportamiento) de la clase padre (superclase)**, e incluso si la heredera no tiene m√©todo constructor, heredar√° el del padre. S√≥lo se podr√° heredar de una superclase directamente, es decir **no hay herencia m√∫ltiple (**s√≥lo es posible con las interfaces)**.** 

Cada subclase podr√° a√±adir sus propias variables/atributos y m√©todos para diferenciarla de las otras subclases. Adem√°s las subclases podr√°n **sobrescribir** los **m√©todos heredados** de las superclases, como se explica en el apartado correspondiente. 

Es muy importante tener claro el uso de ***base*** para poder compaginar los constructores de la clase padre e hija (para ello ver el apartado de constructores en el que se explica) ya que debemos, como m√≠nimo, pasarle los argumentos del constructor de la clase padre al crear el constructor de la clase hija. 

En cuanto a la sintaxis para conseguir la herencia: **class nombreclasehija :  nombreclasehija {}**

-----

**Tipos an√≥nimos** 

Tipo de objeto que se crea en tiempo de compilaci√≥n y que no se declara expl√≠citamente en el c√≥digo fuente. Es una forma r√°pida y conveniente de crear objetos que contienen un conjunto de propiedades y valores, sin tener que crear una clase separada para ello. 

Peculiaridades: 

- Los nombres de las propiedades deber√°n de ser v√°lidos en C#, y los valores deber√°n de ser de cualquier tipo de datos v√°lidos. 

- Este tipo es ***ReadOnly*,** lo que quiere decir que no se pueden modificar los valores de sus propiedades, sino solo leerlos. 

- Por otro lado, se pueden **crear arrays de tipos an√≥nimos** pero se debe tener en cuenta que los objetos dentro de ellos deben de tener la misma estructura, es decir cada new no puede contener un n¬∫ de propiedades diferente ni con nombres distintos. 

`	`**var nombreArray  = new[]**

`	`**{**

`	`**new {identicasPropiedadesEnTodos},**

**new {identicasPropiedadesEnTodos}	//Podemos poner tanto objetos como queramos**

**}**

- **No se pueden usar como tipos de retorno de funciones/m√©todos ni como tipos de par√°metros de m√©todos** ya que su definici√≥n es impl√≠cita y no se puede referenciar desde otro lugar en el c√≥digo.  

**Tampoco se pueden crear listas de tipos an√≥nimos (ni ning√∫n tipo de colecci√≥n gen√©rica**), ya que en una lista es necesario indicar si o si el tipo 

-----

<a name="_pbkzrulg7r04"></a>**INTERFACES**

Las **interfaces** complementan a las **clases abstractas**, pues como ya sabemos, en C# no existe la herencia m√∫ltiple (no se puede heredar de m√°s de una superclase/clase padre), por lo que aparece el concepto de la implementaci√≥n de interfaces (que aunque es muy similar al funcionamiento de herencia, NO es lo mismo ya que una interfaz no es una clase) que si permite que **una clase implemente varias interfaces** (Lo m√°s similar a la herencia m√∫ltiple que encontramos en C#). 

Las interfaces son MUY importantes para abstraer y poder llevar a cabo principios de dise√±o como la Inyecci√≥n de dependencias. 

Las interfaces van a ser un **conjunto/colecci√≥n de anexos/miembros,** los cuales no son m√°s que m√©todos, propiedades(campos, por eso usamos propiedades abreviadas), eventos e indexadores. Estos deber√°n de cumplir con las siguientes caracter√≠sticas: 

- **No pueden tener cuerpo**, es decir no estar implementador, nos limitamos a declarar la firma de m√©todo o propiedad. 
- Siempre **p√∫blicos**, lo cual ser√°n de forma predeterminada por lo que no es necesario especificar expl√≠citamente el modificador de acceso *public*. 
- Siempre son **abstractos**, lo cual ser√°n de forma predeterminada por lo que no es necesario especificar expl√≠citamente el modificador *abstract*. 
- **No pueden ser est√°ticos**. 

La sintaxis para declarar una interfaz ‚Üí se lleva a cabo mediante la palabra reservada ***interface*** de la siguiente manera **interface nombreinterfaz{ //miembros de la interfaz }**   //Por convenci√≥n, el nombre de todas las interfaces **tienen que empezar con una I may√∫scula**

La sintaxis para implementar una interfaz ‚Üí hacemos lo mismo que cuando heredamos una clase. Si adem√°s una misma clase quiere implementar varias interfaces, ponemos el nombre de las mismas separados por comas. 

Es importante tener en cuenta que cuando una clase implementa una interfaz, debe de definir/implementar TODOS los miembros, pues es un contrato a seguir (p.e el **contrato para pertenecer a un club**, siendo cada interfaz un club y una clase puede pertenecer a todos los clubs que quiera siempre y cuando cumpla con los contratos que cada uno de ellos imponga), es decir todas clases que la implementen TIENEN que implementar todos sus miembros. 

Ejemplo: 

` `Ejemplo2: ![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.009.png)

**interface IAnimal**

**{**

`    `**void Eat();**

`    `**void Sleep();**

**}**

**class Dog : IAnimal**

**{**

`    `**public void Eat()**

`    `**{**

`        `**Console.WriteLine("The dog is eating.");**

`    `**}**

`    `**public void Sleep()**

`    `**{**

`        `**Console.WriteLine("The dog is sleeping.");**

`    `**}**

**}**


**\*\*Nota ‚Üí** se pueden crear arrays de una interfaz. Como sabemos una interfaz no se puede instanciar, pues previamente se tiene que implementar por una clase para instanciar objetos de √©sta √∫ltima; no obstante, cuando declaramos el array lo que estamos haciendo es una c√°psula de objetos. Es por esto que los **new** de objetos que ponga dentro si que tienen que ser instancias de objetos un ejemplo: 

`        `**IFish[] fishs = new IFish[]**

`        `**{**

`            `**new Siren(100),**

`            `**new Siren(300),**

`            `**new Shark("Tiburoncin", 70)**

`        `**};**

Vemos que creamos un array de IFish que contendr√° distintos objetos, dichos objetos podr√°n ser de cualquier clase que haya implementado a IFish, como por ejemplo lo son Siren y Shark. (Para ver el c√≥digo completo ver el proyecto *POOInterfaces.* 

Igualmente, si quisi√©ramos hacer un array de solo sirenas pues har√≠amos un array ISiren[] sirens = new Siren[] en cuyo caso s√≥lo contendr√° objetos de tipo sirena. 

-----

<a name="_1ip43tb792zr"></a>**GENERICOS (Generics)** 

Los **gen√©ricos** son una herramienta muy √∫til para crear clases, interfaces y m√©todos que puedan trabajar con diferentes tipos de datos. De forma que en lugar de especificar el tipo de dato que se va a usar, se utiliza un tipo gen√©rico que se especifica al crear la clase y al instanciar objetos de ella, puede tener cualquier nombre, aunque normalmente utilizamos *T* por mera convenci√≥n. De forma que cuando se vaya a crear una variable, propiedad u objeto en vez de poner un tipo como *int, string, float,* etc, podemos el nombre del tipo gen√©rico que queramos permitiendo mejorar la seguridad de tipos y el rendimiento, ya que no es necesario hacer conversiones de tipos en tiempo de ejecuci√≥n. 

Sintaxis para crear una clase gen√©rica: 

`	`**class NombreDeMiClase<T>**

`	`**{**

`		`**//C√≥digo que queramos en el que se use el tipo gen√©rico p.e si la clase fuese MyList<T>: :** 

`		`**private T[] \_elements;**

**private int \_index = 0;**  
**


`		`**public MyList(int n)**

`		`**{**

`			`**\_element = new T[n];**

`		`**}**

`		`**public void Add(T e)**

`		`**{**

`			`**if(\_index < \_elements-Length)**

`			`**{**

`				`**\_elements[\_index] = e;**

`				`**\_index++;**

**}**

**}**

//De esta manera da igual el tipo del cual sea T porque siempre vamos a a√±adir con Add dicho elemento al array creado. 

`	`**}**

Sintaxis para instanciar una clase gen√©rica: 

`	`**NombreDeMiClase<tipodelquequieroquesea> NombreDeObjeto = new NombreDeMiclase<tipodelquequieroquesea>();** 


**\*\*Nota ‚Üí** Cuando queramos inicializar, devolver un valor vac√≠o de T, como no sabemos si el tipo utilizado acepta null, lo que usamos siempre es **default(T)** que devolver√° el valor predeterminado del tipo de datos T,el cual podr√° ser null, 0, false, ‚Äú‚Äù, etc.

**\*\*Nota ‚Üí** Para ver el c√≥digo completo de ejemplo ver *Genericos*.

-----

<a name="_41b524oap7xp"></a>**M√âTODO MAIN**

Es el m√°s importante en nuestro programa, pues conlleva el punto de entrada y salida de nuestra aplicaci√≥n (en √©l se inicializa y finaliza el control de un programa), siendo su principal tarea dirigir las llamadas a otras funciones y m√©todos en C#. Es por todo ello que main debe ser **static** **(**dado que main es lo primero que se ejecuta, no tiene un objeto para instanciar**),** no public (es private por defecto) y declararse dentro de la clase que le da el nombre a nuestra aplicaci√≥n.

**public class NombreDeLaApp {**

`	`**public static void main(String[] args) {**

`		`**. . . .**

**}**

**}**

Particularidades: 

- Siempre recibe **argumentos** (del programa)** del tipo **String** y de ning√∫n otro, pues si le pasamos un int lo convertir√° a un String. No obstante, **se puede declarar sin un par√°metro string[]** y usar el m√©todo ***GetCommandLineArgs()***. 
- Podr√° **devolver** **void, int, Task** o **Task<int>** (en estos dos √∫ltimos casos podr√° incluir el modificador ***async)***.  
- Cuando este m√©todo es llamado desde otro m√©todo, se crea un array con los argumentos del programa y lo podemos recorrer/mostrar su contenido por medio de un bucle for. Cabe destacar que el nombre de dicho array ser√° **args**, y para acceder a √©l podremos usar **args[n¬∫]** o para conocer cu√°ntos hay **args.length**; aunque podremos cambiar la palabra **args** por cualquier otro nombre que queramos. 

A diferencia de C y C++, el nombre del programa no se es el primer argumento de l√≠nea de comandos, pero si el primer elemento del m√©todo *GetCommandLineArgs()*. 

As√≠ pues, con todo lo dicho anteriormente, la siguiente lista muestra la **signaturas v√°lidas** para Main: 

**public static void Main() { }**

**public static int Main() { }**

**public static void Main(string[] args) { }**

**public static int Main(string[] args) { }**

**public static async Task Main() { }**

**public static async Task<int> Main() { }**

**public static async Task Main(string[] args) { }**

**public static async Task<int> Main(string[] args) { }**

**Instrucciones de nivel superior, programas sin m√©todos Main**

A partir de C#9, no es necesario incluir expl√≠citamente un m√©todo Main en los proyectos de aplicaci√≥n de consola. En su lugar, se puede usar *instrucciones de nivel superior* para minimizar el c√≥digo. En este caso, el compilador genera una clase y un punto de entrada de forma impl√≠cita. Por lo que podemos directamente lanzarnos a escribir las l√≠neas de c√≥digo. La **reglas** para poder usar esta pr√°ctica son: 

- **Solo un archivo de nivel superior**, pues si tenemos varios archivos dentro de nuestro proyecto, s√≥lo uno de ellos puede tener instrucciones de nivel superior, ya que solo puede haber un punto de entrada del programa. (De lo contrario saldr√° error). 
- **Ning√∫n otro punto de entrada,** si escribimos un m√©todo Main de forma expl√≠cita, el compilador lo ignorar√° como un punto de entrada y mostrar√° un warning. 
- **Espacios de nombres,** todas las instrucciones de nivel superior est√°n impl√≠citamente en el espacio de nombres global (*namespaces global*). Aunque puede contener namespaces y definiciones de tipos, siempre y cuando aparezcan **despu√©s de las instrucciones de nivel superior**. 
- Las instrucciones de nivel superior pueden hacer referencia a la variables **args** y llamar al m√©todo asincr√≥nico con **await**. 
- **C√≥digo de salida para el proceso**, para devolver un valor **int** cuando se finaliza la aplicaci√≥n, se debe usar ***return.*** 

As√≠ pues, la **signatura** del m√©todo de punto de entrada depender√° de lo que incluyan las instrucciones de nivel superior: 

`	`Si incluye *await* y *return* 	**static async Task<int> Main(string[] args)**
\*
`	`Si incluye *await* 		**static async Task Main(string[] args)**
\*
`	`Si incluye *return* 		**static int Main(string[] args)**
\*
`	`No incluye ni *wait* ni *return*	**static void Main(string[] args)**
\*


-----


<a name="_h7z0r55r5pnb"></a>**PAQUETES Y LIBRER√çAS** 

Una  **librer√≠a/biblioteca** es un c√≥digo prescrito,  precompilado y reutilizable que nos proporciona diferentes funcionalidades y puede contener funciones o clases que realizan una tarea espec√≠fica y se pueden enlazar o invocar. Mientras que los **paquetes** son colecciones de m√≥dulos, que pueden contener var√≠as o solamente una librer√≠a junto con sus dependencias y metadatos asociados. 

En C# un paquete es una unidad de distribuci√≥n de c√≥digo que contiene uno o m√°s ensamblados; y la bibliotecas se implementan como ensamblados, que son archivos DLL o EXE que contienen el c√≥digo compilado. As√≠ pues, en C# las bibliotecas y paquetes son esencialmente lo mismo, ya que ambos son ensamblados que contienen c√≥digo que puede ser reutilizado en diferentes proyectos. Sin embargo, los paquetes generalmente se refieren a las bibliotecas que se distribuyen a trav√©s de un administrador de paquetes, mientras que las bibliotecas se pueden distribuir de otras forma, como a trav√©s de archivos ZIP o inclusi√≥n directa del c√≥digo fuente en un proyecto.

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

Cabe tener en cuenta que los paquetes en C# son lo **primero que se declara** y se debe declarar en **min√∫sculas**. La sintaxis para declarar paquetes es ‚Üí **using NombreDelPaquete** 	

En C#, los paquetes y bibliotecas se gestionan a trav√©s de un administrador de paquetes, el m√°s utilizado es NuGet, que se integra en VS y permite buscar, instalar y actualizarlos en un proyecto. Para agregar uno a un proyecto podemos hacerlo siguiendo estos pasos: 

1. Clic derecho en el proyecto de la ventana soluci√≥n ‚Üí *Administrar paquete NuGet.* 
1. Buscamos el paquete que queremos instalar por su nombre. 
1. Damos click en instalar una vez encontrado, para agregarlo al proyecto. 
1. Si queremos utilizar un paquete que no est√° disponible en NuGet, podemos descargar el archivo de la p√°gina web del proveedor y agregarlo al proyecto manualmente. Para ello, hacemos clic derecho en la ventana soluci√≥n del proyecto ‚Üí *Agregar ‚Üí Referencia.* 
1. Seleccionamos el archivo. 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

Nosotros tambi√©n podemos crear librer√≠as, para ello las **importamos** (tanto si son nuestras ubicadas en otra parte del programa general o de Java). En los siguientes ejemplos podemos ver la sintaxis a llevar a cabo (debe indicarse al principio del programa despu√©s de declarar los paquetes: 

- **import paquetequesea.otropaquete.\*;		//Se importan todas las clases pertenecientes a ‚Äúotropaquete‚Äù.** 
- **import paquetequesea.otropaquete.MiClase;		//Se importa directamente una clase del paquete** 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

Entre las **librer√≠as est√°ndar m√°s importantes** se encuentran: 

- **java.applet ‚Üí** se incluyen clases para crear applets.
- **java.awt ‚Üí** se incluyen las clases para crear interfaces de usuario con ventanas.
- **java.net ‚Üí** se incluyen clases que admiten aplicaciones que acceden a redes TCP/IP.
- **javax.swing ‚Üí** se incluyen clases para crear interfaces de usuario mejorando AWT. 

- **java.time ‚Üí** se incluyen clases para el manejo de fechas. Estas clases surgen de Joda-Time (biblioteca gratuita y de c√≥digo abierto) cuyos desarrolladores trabajaron junto a Oracle para mejorarla. entre sus clases destacan: 

- **LocalDate ‚Üí** Muestra fechas sin la hora, lo cual nos conviene para declarar, sumar, restar o comparar fechas.
- **LocalTime ‚Üí** Es igual que el anterior, pero se utiliza en la gesti√≥n de horas, sin fechas asociadas, para poder compararla, sumar o restar. 
- **LocalDateTime ‚Üí** Mezcla de las dos primeras, lo que te permite hacer los mismos c√°lculos con fechas y horas al mismo tiempo. 
- **Instant ‚Üí** es igual a la anterior, aunque almacena un punto en el tiempo, es decir, una fecha y hora, pero almacenando su valor como un timestamp de UNIX (cantidad de segundos transcurridos desde la medianoche UTC del 1/1/1970, sin contar segundos intercalares).
- **ZonedDateTime ‚Üí** Similar a LocalDateTime, pero considerando una zona horaria concreta (mientras que las anteriores no). 
- **Period ‚Üí** esta clase permite recuperar la diferencia entre fechas para diferentes per√≠odos (segundos, min, d√≠as‚Ä¶) y agregar estas diferencias a las fechas. 
- **Duration ‚Üí** similar a la anterior pero solo para la gesti√≥n de horas. 

- **java.io ‚Üí** se incluyen clases que manejan entradas/salidas. 

- **Serializable ‚Üí** interfaz de marcador (no tiene m√©todos ni atributos), por ello las clases que lo implementan no tienen que implementar ning√∫n m√©todo. Se implementa cuando queremos que las instancias de dicha clase (la que est√° implementando java.io.Serializable) se serialicen (se realiza mediante ObjectOutputStream) o deserialicen (se realiza mediante ObjectInputStream). 

El hecho de que una clase implemente esa interfaz no significa que sea heredera de ella. 

[Ejemplo de c√≥mo serializar y deserializar un objeto en Java](https://www.geeksforgeeks.org/serializable-interface-in-java/)  p.e public class Persona  implements Serializable{	

Tanto los arrays y las cadenas, como los tipos b√°sicos de Java son serializables, pues se trata de objetos que tienen propiedades que hacen referencia a otros objetos. 

- **PrintWriter() ‚Üí** Como hemos visto se trata de un objeto perteneciente a la clase **java.io**. Este constructor acepta como par√°metro un archivo si queremos que escriba en un archivo, o una cadena de caracteres si queremos decirle el nombre del archivo en el que queremos escribir. Otro par√°metro (opcional) es ***autoFlush*** que no es m√°s que un boolean que indica si queremos que tenga autoflushing (forzar a que se vuelque/escriba todo el contenido) o no. 

Como tercer par√°metro (opcional) podemos pasar un Charset, es decir el tipo de codificaci√≥n (p.e UTF8 o UTF16). 

Creado el objeto tipo PrintWriter, podemos usar cualquiera de sus m√©todos: 

- **print(), println()**
- **printf() ‚Üí** este como ya vimos en C, permite formatear el string con el uso de %. 
- **close() ‚Üí** para cerrar el fichero, en caso de que hayamos elegido uno para escribir sobre √©l. 
- **checkError() ‚Üí** permite comprobar si hay un error 
- **append() ‚Üí** permite concatenar las cadenas (aunque como ya sabemos podemos hacerlo tambi√©n a pelo dentro de los print mediante **+**). 
- **flush() ‚Üí** permite hacer flush en la salida, es decir volcarlo todo. Se recomienda hacer flush antes de cerrar, es decir antes de usar close(). 

- **java.lang ‚Üí** se incluyen varias pero esenciales clases del lenguaje, como Object, Thread o Math. Este se importa a los archivos de c√≥digo Java de forma predeterminada, es decir no tenemos que hacerlo expresamente nosotros. 

- **System ‚Üí** contiene varios m√©todos de entrada y salida de datos por pantalla y de salida de error. Proporciona un stream que es una especie de canal por donde fluyen los datos tanto de entrada (a trav√©s del teclado), como de salida (a trav√©s de la pantalla u otro dispositivo). 

Esta clase posee tres m√©todos est√°ticos: 

- **Standard Input Stream (System.in) ‚Üí** se utiliza junto con la clase **Scanner** para ingresar datos por teclado o desde un archivo. P.e Scanner entrada=new Scanner(System.in) 
- **Standard Output Stream (System.out) ‚Üí** se utiliza junto a la funci√≥n **print/println/printf** para la salida de informaci√≥n por pantalla. **P.e System.out.printIn(‚ÄúLo que queramos mostrar‚Äù)**
- **Standard Error Stream (System.err) ‚Üí** tambi√©n se utiliza junto a la funci√≥n **print/println/printf** pero incluyendo una e que representa error. **P.e System.err.printIn(‚ÄúMensaje de Error‚Äù+e)** 
- **System.exit(c√≥digodeestado) ‚Üí** permite salir del programa actual al finalizar la ejecuci√≥n de la m√°quina virtual Java. Adem√°s toma un c√≥digo de estado de finalizaci√≥n del programa (**0** indica **terminaci√≥n exitosa**, y cualquier otro valor indica una **terminaci√≥n fallida**, normalmente **1** o **-1**).

**\*\*Nota ‚Üí** cuando queramos concatenar varios datos en un mismo print, bastar√° con poner **+**. Si lo que ponemos no es una cadena directamente usando ‚Äú ‚Äú, sino una variable, bastar√° con poner el nombre de la variable sin comillas. 

**\*\*Nota ‚Üí** con el m√©todo **printIn** el mensaje se muestra en pantalla y luego el cursor queda en el rengl√≥n siguiente; mientras que al usar **print** se muestra el mensaje y el cursor queda al final de la l√≠nea. 

Por otro lado, desde la v1.5 de java, est√° disponible **printf**, cuyo funcionamiento es igual al conocido en C: 

Permite mostrar una cadena de texto con formato por la salida est√°ndar, admitiendo un n¬∫ variable de argumentos. En el caso de la cadena **format** √©sta contiene s√≠mbolos de sustituci√≥n que ser√°n reemplazados con el resto de argumentos en estricto orden, es decir debemos indicar entre ‚Äú ‚Äú todo lo correspondiente a format y seguido de una , se deber√°n de indicar el nombre de las variables que sustituir√°n a los s√≠mbolos de sustituci√≥n: 

- **%d** reemplazar√° un **entero** con **formato decimal.**  
- **%f** reemplazar√° un **real** con **formato decimal** (podemos indicar el n¬∫ de decimales % .**3f**)
- **%s** reemplazar√° una **cadena de caracteres.**   
- **%c** reemplazar√° un **car√°cter.**   
- **%lu** reemplazar√° un **long unsigned**.

- **Thread ‚Üí** Clase, explicada en MULTITAREA. 
- **Runnable ‚Üí** Interfaz, explicada en MULTITAREA. 

- **java.util ‚Üí** se incluyen clases que permiten el acceso a los recursos del sistema, etc. 

- **Scanner ‚Üí** mejor clase para recibir informaci√≥n (datos primitivos) a trav√©s del teclado y/o de ficheros. No obstante, cabe destacar que si deseamos un m√©todo de entrada con limitaciones de tiempo, esta clase no es muy eficaz. 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.010.png)

Para utilizarla hay que crear un objeto de clase Scanner. 

`	`**Scanner nombrevar1=new Scanner(par√°metro que indica de d√≥nde proceden los datos);**  

//Si ponemos System.in como par√°metro, se considerar√° el teclado. Por el contrario podemos poner cualquier archivo a leer

Para capturar la informaci√≥n ingresada es necesaria otra variable que ‚Äúreciba‚Äù los datos introducidos por el teclado (debemos repetir este proceso cada vez que queramos  pedir algo por teclado..):

`	`**tipovar nombrevar2=nombrevar1.m√©todo;** 
**


El m√©todo podr√° ser cualquiera de los siguientes (cabe destacar que si ingresamos un tipo de dato que no es el esperado, Java nos da error): 

- **nombrevar2.next() ‚Üí** lee un String hasta encontrar un delimitador, generalmente un espacio. Usando **nombrevar2.useDelimiter();** al cual se le debe pasar como par√°metro el delimitador que queremos, por ejemplo ‚Äú\\s\*, \\s\*‚Äù  establece que el delimitador es una coma precedida o no de uno o m√°s espacios y seguida o no de uno o m√°s espacios, pues \\s es un espacio y el asterisco indica cero o m√°s. 
- **nombrevar2.nextBoolean() ‚Üí** Lee valores booleanos. 
- **nombrevar2.nextByte() | nextDouble() | nextFloat() | nextShort() | nextInt() | nextLong()** 
- **nombrevar2.nextLine ‚Üí** Lee un String hasta encontrar un salto de l√≠nea. Devuelve la l√≠nea siguiente a leer. 
- **nombrevar2.hasNextLine() o Byte, Int etc etc‚Üí** nos devuelve un boolean que indica si hay o no una l√≠nea, byte, int etc etc  m√°s que leer. 

Una vez creada la variable objeto y recibido su contenido (se hace en el momento de crear el objeto (nombrevar2). Cuando ya no queramos usarlo m√°s, pasamos a cerrar la clase con el siguiente m√©todo:

**nombrevar1.close() ‚Üí** Cierra la clase Scanner luego de utilizarla. (nombrevar1) 

- **ArrayList ‚Üí** esta clase proviene de la interfaz *Collection*  -> *List,* pues esta √∫ltima implementa a AbstractList, la clase de la que hereda ArrayList. En cuanto a la diferencia frente a un Array es la misma diferencia entre una colecci√≥n (ArrayList es una) y los Array como podremos ver en el apartado correspondiente. No obstante, la sintaxis si varia un poco: 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.011.png)

Para declarar un array ‚Üí **ArrayList<tipodedato> nombredelarray = new ArrayList<tipodedato>();** 

Para acceder al dato de una posici√≥n concreta ‚Üí **nombredelarray.get(posicion)**;

Para a√±adir elemento al array (cabe destacar que los objetos se a√±aden en orden FIFO, por lo que el √∫ltimo que entra ocupa la √∫ltima posici√≥n de la lista) ‚Üí **nombredelarray.add(valordeldato);** 

Modificar el valor de una posici√≥n ‚Üí **nombredelarray.set(posicion, nuevovalor);**

Borrar uno/todos el/los elemento/s ‚Üí **nombredelarray.remove(posicion);  || nombredelarray.clear();** 

Cuando borramos un elemento la tabla se recoloca, por eso cuando borremos un elemento por su valor (usando bucles e if ) y no por su posici√≥n, debemos salir de las estructuras (if, bucles‚Ä¶) para que Java pueda reacomodar el array. 

En la explicaci√≥n de colecciones hay m√°s m√©todos como size. 

- **LinkedList ‚Üí** esta clase proviene de la interfaz *Collection -> List,* pues esta √∫ltima implementa la clase AbstractList que a su vez hereda en AbstractSequentialList, la clase de la cual hereda LinkedList. Esta representa una **lista doblemente enlazada** (ida y vuelta), esto quiere decir que todas las posiciones . Gracias a ello tambi√©n puede ser usada/tratada como una **pila** o **cola,** ya que permite insertar/eliminar los elementos del principio y del final, es decir permite tanto el orden FIFO como LIFO. ![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.012.png)

Como se puede observar el elemento del principio solo apunta hacia el de adelante y el √∫ltimo solo apunta hacia el anterior; mientras que los del medio apuntan tanto hacia delante como hacia atr√°s. 

Dado que tanto LinkedList como ArrayList son implementadas por la interfaz *List*, ambas pueden utilizar los mismos m√©todos (a√±adir elementos, cambiarlos, borrarlos‚Ä¶). No obstante, dado que LinkedList no tiene los elementos indexados y puede ser alterada tanto por el principio como por el final, LinkedList incluye unos m√©todos espec√≠ficos para llevarlo a cabo por el principio de la lista o el final de la misma: 

Para declarar un array ‚Üí **LinkedList<tipodedato> nombredelarray = new LinkedList<tipodedato>();** 

Para acceder al dato de una posici√≥n concreta ‚Üí **nombredelarray.\***; **|| getFirst || getLast || get(posici√≥n)**

Para a√±adir elemento a la lista‚Üí **nombredelarray.\*; || addFirst || addLast || add()** //Este equivale a addLast (FIFO)

Modificar el valor de una posici√≥n ‚Üí **nombredelarray.set(posicion, nuevovalor);** 

Borrar uno/todos el/los elemento/s ‚Üí **nombredelarray.\*; || removeFirst() || removeLast() || remove(posicion) ||                   nombredelarray.clear();** 

Cuando estemos llevando a cabo la eliminaci√≥n de un elemento cuya posici√≥n desconocemos, utilizaremos bucles e if. En ese caso tenemos que tener en cuenta que una vez encontrado el elemento y borrado debemos salir de las estructuras para dejar que Java reacomode la lista acomod√°ndose los punteros. 

En la explicaci√≥n de colecciones hay m√°s m√©todos como size. 

- **Stack ‚Üí** esta clase hereda de *Vector* que a su vez es implementada por la interfaz *Collection*. La **pila** a diferencia de los ArrayList y los LinkedList, tiene ordenaci√≥n **LIFO**, es decir el √∫ltimo en entrar es el primero en salir. En cuanto a su sintaxis es muy similar: 

Para declarar un array ‚Üí **Stack<tipodedato> nombrepila= new Stack<tipodedato>();** 

Para acceder al dato de una posici√≥n concreta ‚Üí **nombredelarray.get(posicion**; 

Para a√±adir elemento a la pila‚Üí **nombrepila.push(datoaa√±adir);**   //Este equivale a ordenaci√≥n LIFO

Modificar el valor de una posici√≥n ‚Üí **nombrepila.set(posicion, nuevovalor);** 

Borrar uno/todos el/los elemento/s ‚Üí **nombrepila.pop();**     //Elimina el √∫ltimo elemento que entr√≥ (LIFO)**  

`                 `**nombrepila.clear();** 

Buscar en una pila directamente ‚Üí **nombrepila.search(datoabuscar);** 

`        `//Devuelve la posici√≥n que ocupa en la pila (empieza en 1 y no en 0, y es seg√∫n el 

`                          `orden LIFO, es decir el **√∫ltimo en entrar ocupa la 1 posici√≥n**. Devuelve **-1** si no lo 

`	         `encuentra.

`	         `Este no funciona expresamente con objetos (clases instanciadas). 

Obtener el √∫ltimo elemento a√±adido a la pila ‚Üí **nombrepila.peek();**

En la explicaci√≥n de colecciones hay m√°s m√©todos como size. 

-----

<a name="_i6709oszcw6m"></a>**ESTRUCTURA DE PROYECTO** 

1. Declaramos los paquetes.  
1. Importamos otros paquetes o propios. 
1. Declaramos una clase p√∫blica que deber√° contener el m√©todo main(), el cual es el m√©todo principal de todo proyecto. 
1. Declaramos las variables, puede ser antes o despu√©s del main(). 
1. Declaramos el m√©todo main, su presencia es imprescindible, pues es el punto de entrada a nuestra App. Sin este m√©todo no funcionar√° el programa.
1. Declaraciones de variables de instancias, para trabajar con un objeto dentro de nuestro programa , precisamos instanciar (crear) el objeto, al crearlo puede tener variables distintas a otro objeto de la misma clase. 
1. Definici√≥n de constructores. 
1. Definici√≥n de m√©todos. 
1. Comentarios. 

-----

<a name="_6ak7mxrfkeoo"></a>**EXCEPCIONES JAVA** 

Errores producidos en tiempo de ejecuci√≥n como consecuencia de un fallo en una instrucci√≥n del programa, como al dividir por cero, no abrir un archivo correctamente‚Ä¶etc. Las excepciones producir√°n **mensajes de error en la pantalla y finalizan la ejecuci√≥n del programa**; adem√°s se crea un objeto de alguna clase (dependiendo del tipo de error que haya ocurrido) que contendr√° informaci√≥n sobre el error que se gener√≥ y nos proporcionar√° los m√©todos necesarios para obtener dicha informaci√≥n. 

La **clase padre** de dichas clases es **Throwable**, est√° da lugar a dos subclases *Error,*  errores** (situaci√≥n que no se espera y que interrumpe la ejecuci√≥n del programa) y *Exception,* excepciones (situaci√≥n que no se espera pero que se puede capturar y en base a ello dirigir el flujo del programa hacia otro lado). 

Existen **dos tipos** de excepciones en java: 

- Propias de Java como lenguaje![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.013.png)
- Personalizadas (creadas por nosotros mismos) 

Existen innumerables excepciones propias de Java las cuales se van tomando con la experiencia y que ir√© poniendo en la siguiente lista: 

- **RuntimeException ‚Üí** se tratan de excepciones NO comprobadas y ocurren dentro de la m√°quina virtual de Java durante el tiempo de ejecuci√≥n, suelen ser errores del programador. 

- **ArithmeticException ‚Üí** se produce por errores en cuanto a operaciones aritmetol√≥gicas no permitidas. 
- **ArrayIndexOutOfBounds ‚Üí** se produce cuando el √≠ndice es negativo y ‚â• que el tama√±o del array. 
- **NullPointerException ‚Üí** se produce cuando se intenta usar una referencia nula en el uso de un objeto. 

- **IOException ‚Üí** se√±ala alg√∫n tipo de error en una operaci√≥n de entrada/salida (suelen ocurrir al procesar archivos u operaciones de red).  Se conocen como *excepciones comprobadas*, pues no son culpa del programador. P.e una sentencia que debe leer un archivo, hemos puesto bien la ruta y no hay errores de sintaxis, pero alguien removi√≥ ese archivo y el programa no lo encuentra para utilizarlo.

- **FileNotFoundException ‚Üí** error de entrada/salida que indica que cuando se abri√≥ el archivo, no exist√≠a en el sistema de archivos. 

- **ClassCastException ‚Üí** se produce si se realiza una operaci√≥n de cast en un tipo de objeto que no es una instancia. 
- **IllegalArgumentException ‚Üí** se√±ala que el valor de un argumento no es v√°lido y generalmente se usa para verificar una condici√≥n previa al comienzo de un m√©todo. 
- **ClassNotFoundException ‚Üí** se produce cuando se intenta cargar una clase, pero no existe. Suele darse porque la biblioteca no est√° disponible en el classpath cuando se inicia el programa o la app requiere otra versi√≥n de una biblioteca. 
- **NoClassDefFoundError ‚Üí** equivale a la anterior, con la diferencia de que la clase existe en tiempo de compilaci√≥n, pero no en tiempo de ejecuci√≥n. 
- **NoSuchMethodException ‚Üí** se produce cuando no se encuentra el m√©todo. Esto es posible cuando una nueva versi√≥n de la biblioteca elimina un m√©todo o cambia su firma con un cambio no compatible con versiones anteriores. 
- **SQLException ‚Üí** se produce al acceder a una base de datos relacional, p.e si la instrucci√≥n SQL no tiene la sintaxis correcta. 
- **StackOverflowError ‚Üí** se produce cuando hay demasiadas llamadas recursivas a un  m√©todo. 
- **InterruptedException ‚Üí** se produce cuando se interrumpe un thread p.e por usar hilos y operaciones simult√°neas. 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

<a name="_pyse97o9jtch"></a>**Control de excepciones** 

Permite automatizar una enorme cantidad de c√≥digo que antes ten√≠a que a√±adirse ‚Äúmanualmente‚Äù, pues simplifica el control de errores al hacer que nuestro programa cree un bloque de c√≥digo llamado **controlador de excepciones**, que se ejecutar√° autom√°ticamente cada vez que se produzca un error, permitiendo as√≠ que no se requiera verificar de forma manual el √©xito o fracaso de todas las llamadas del m√©todo u operaci√≥n espec√≠ficos. 

Java define una serie de excepciones estandarizadas para los errores m√°s comunes de los programas, as√≠ el programa es capaz de percibir y controlar dichas excepciones; adem√°s la biblioteca API de Java hace un uso extensivo de las excepciones. 

El control de excepciones se administra a trav√©s de **cinco palabras clave** que crean un subsistema interconectado donde utilizando una, se utilizan las dem√°s ( [ejemplos](http://dis.um.es/~bmoros/Tutorial/parte9/cap9-3.html)  [OtroEjemplo+](https://www.tutorialesprogramacionya.com/javaya/detalleconcepto.php?codigo=165) ) : 

- **try ‚Üí** dentro de este bloque se debe incluir el c√≥digo, de forma que si ocurre una excepci√≥n dentro de dicho bloque, √©sta se lanzar√°. 
- **catch ‚Üí** permite capturar la excepci√≥n que se le indique y manejarla de manera sensata. Equivale un poco al ‚Äúelse‚Äù del try, pues se ejecutar√° cuando se dispara una excepci√≥n en el bloque try. 
- **finally ‚Üí** es un bloque opcional, que en caso de usarlo, se ejecuta siempre, con independencia de que se haya ejecutado √∫nicamente el try o se haya ejecutado el catch, es decir con independencia de que se produzca o no un error.   
- **throw (lanzar) ‚Üí** permite lanzar excepciones manualmente. Es decir, en la parte del c√≥digo que queramos indicamos a trav√©s de esta sentencia que se debe lanzar la excepci√≥n que indiquemos, de alguna manera es como forzarla. La sintaxis para poder usarlo:

`	`**if (n==0) throw new nombreexcepci√≥n(‚Äúmensaje que queremos que se muestre en la terminal‚Äù);** 
**

**
`	`o bien sin new, pero usandolo dentro del catch

Tras esto, Java har√° escalar la excepci√≥n hacia arriba hasta hallar dentro de otro m√©todo un bloque de c√≥digo que la capture (*try-catch*), si no lo encuentra, seguir√° subiendo hacia el m√©todo inmediato superior a ver si lo encuentra all√≠, si sigue sin encontrarlo, el programa se detiene. 

- **throws (lanza un 3¬∫, es decir un m√©todo) ‚Üí** si un m√©todo es capaz de provocar una excepci√≥n que no maneja √©l mismo, deber√≠a de usar throws. Permite identificar la lista (separadas por ,) posible de excepciones que un m√©todo puede lanzar. √âste se utiliza para todas las subclases de la clase *Exception* excepto si es de tipo RuntimeException o cualquiera de su subclases. Por ello se suele utilizar junto a throw, solo que en este caso no se indica como sentencia del bloque sino que se usa antes de las {} del m√©todo. 

`	`**\_\_\_ nombrem√©todo(argumentos) throws excepciones {}** 

‚Üí try y catch se utilizan juntos, la sintaxis para ello es la siguiente: 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.014.png)

**try{** 

**//bloque de c√≥digo para monitorear errores**

**}**

**catch (TipoExcepci√≥n1 ex0b){			\*\***

**//Manejador para TipoExcepci√≥n1**

**}**

**catch (TipoExcepci√≥n2 ex0b){**

**//Manejador para TipoExcepci√≥n2**

**}**

**SI HUBIESE UN RETURN, √âSTE DEBE INDICARSE FUERA DEL TRY AND CATCH** 

**\*\***Lo que contiene el catch dentro del par√©ntesis debe de ser el nombre exacto de la excepci√≥n o el nombre de la clase superior (en ese caso ser√≠a *Exception,* pues todas las excepciones provienen de √©sta). Por otro lado, *ex0b* puede ser sustituido por cualquier letra/nombre, ya que sencillamente ser√° la variable que guarde la informaci√≥n del error producido.***   

Cuando creamos **excepciones personalizadas**, la clase debe heredar siempre de ***Exception***. 

-----

<a name="_x4nf8dx5dv1o"></a>**JSON** 

JSON (JavaScript Object Notation) es un formato ligero de **intercambio de datos** que se utiliza para enviar y recibir datos entre aplicaciones web (se pueden comunicar aplicaciones de lenguajes diferentes). Es una alternativa al formato XML (este supone aprox un 75% de metainformaci√≥n para un 25% de informaci√≥n, lo cual no es tan √≥ptimo), raz√≥n por la que JSON es mejor, adem√°s de ser f√°cilmente legible por humanos y por m√°quinas. 

La raz√≥n por la que JavaScript aparece en las siglas de JSON es porque cada vez que guardamos datos con JSON, almacenamos un objeto JavaScript. 

Se basa en una estructura de pares de **nombre/valor** (los valores pueden ser cadenas de texto, n√∫meros, objetos, matrices, valores booleanos y valores nulos (null)), y se utiliza principalmente para representar datos estructurados en forma de **objetos** o **matrices**. 

Su sintaxis** es muy sencilla, donde los datos se representan como una colecci√≥n de pares de nombre/valor, separados por comas, y delimitados por **llaves {}** para **objetos** y **corchetes []** para **matrices**. p.e: 

Objeto ‚Üí **string json = ‚Äú{\‚ÄùName\‚Äù: \‚ÄùLoliPop‚Äù, \‚ÄùBrand\‚Äù: \‚ÄùFiesta\‚Äù}‚Äù;**	      //Usamos \ solo para escapar las comillas dentro de las comillas

Matriz ‚Üí **string json2 = ‚Äú[‚Äú +** 

` `**‚Äú{\‚ÄùName\‚Äù: \‚ÄùLoliPop‚Äù, \‚ÄùBrand\‚Äù: \‚ÄùFiesta\‚Äù},‚Äù +** 	//Los objetos deben de separarse con , 

` `**‚Äú{\‚ÄùName\‚Äù: \‚ÄùLoliPop‚Äù, \‚ÄùBrand\‚Äù: \‚ÄùFiesta\‚Äù}‚Äù +** 

**‚Äú]‚Äù;**
**


C# como la mayor√≠a de lenguajes, tiene m√©todos para convertir formato JSON a objetos y viceversa, evit√°ndonos tener que hacerlo a mano, para ello debemos importar el paquete System.Text.Json para poder usar la clase **JsonSerializer**, tanto para serializar (m√©todo **Serialize)** como para deserializar (m√©todo **Deserialize**):: 

- ***Convertir objeto a formato Json ‚Üí* string nombreObjetoJson = JsonSerializer.Serialize(nombreDeObjetoaConvertir);** 

- ***Convertir formato Json a objeto ‚Üí*** 

**NombreClaseObjeto nombreInstaciaObjeto = JsonSeializer.Deserializer<NombreClaseObjeto>(nombreDeJsonAConvertir);**

**NombreClaseObjeto[]                                                                                         <NombreClaseObjeto[]>**  	//Si es una matriz



\*\***Nota ‚Üí** ver qu√© es **serializar** (objeto en cadena JSON)**  y **deserializar** (cadena JSON en un objeto) en el [Glosario.](https://docs.google.com/document/d/1awoy3Nl8ITfb-t5iZXxphebcRHGZIcaW9a7weKu-qKo/edit) 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

**Creaci√≥n de ventanas y componentes**

Las **ventanas de la biblioteca AWT** se incluyen en la clase **Frame**. Podemos crear una GUI usando Frame de **dos formas ([Ejemplos](https://quejava.com/tutorial-de-java-awt-para-principiantes/))**: 

- *Ampliaci√≥n/extensi√≥n de la clase Frame* *‚Üí*  consiste en crear una clase heredera de Frame. La diferencia entre el c√≥digo cuando lo hacemos de esta manera en vez de la siguiente, es que al no tener que crear una instancia de un objeto frame, no debemos indicar **nombreobjeto.m√©todo**, sino que usamos los m√©todos de Frame de forma directa. 

- *Creando la instancia de la clase Frame directamente* ‚Üí Cuando creamos una instancia de un objeto Frame, √©ste contendr√° borde y t√≠tulo adem√°s de la posibilidad de incluir una barra de men√∫:  

**Button botonTitulo = new Button(‚ÄúTexto del bot√≥n‚Äù);**	//Creamos un bot√≥n

**Frame miFrame = new Frame (‚ÄúT√≠tulo de la ventana‚Äù);** 	//Crear ventana

**miFrame.setLayout(new FlowLayout());**	//FlowLayout es un controlador de posicionamiento que pone los componentes encadenados en forma

`				`//de lista, de izquierda a derecha. 

**miFrame.add(botonTitulo);**		//A√±adimos el objeto bot√≥n al frame

**miFrame.setSize(100, 200);**		//Indicamos el ancho y alto (respectivamente) que queremos que tenga la ventana

**miFrame.setVisible(true);**		//Hacemos visible la ventana


Para poder interactuar con una interfaz visual, es decir, para poder reaccionar y ejecutar c√≥digo cuando se presionan los botones, se mueve el rat√≥n, se escribe, etc., se deben administrar los eventos. Un **evento** es una se√±al que comunica a una aplicaci√≥n que ha sucedido algo importante. P.e usuario hace click en un control en un formulario, el formulario puede provocar un evento click y llamar a un procedimiento que controla dicho evento. 

Los eventos de Java se organizan dentro del paquete **java.awt.event** (importamos java.awt.event.\*): 

- **java.awt.AWTEvent ‚Üí** base para los eventos utilizados para la construcci√≥n de GUIs. 
- **java.util.EventObject ‚Üí** clase base para todos los eventos en Java. 

**(Esto mejor verlo en ejemplos y en las explicaciones de los componentes)** Para implementar de manera sencilla algunos controladores de evento, el paquete **java.awt.event** incluye una clase base **XxxAdapter** que implementa la interfaces **XxxListener**. Los eventos **XxxEvent** tienen una interfaz **XxxListener** asociada, gracias a la cual podemos definir manejadores de eventos: 

- **MouseAdapter ‚Üí** para manejar los eventos del rat√≥n.
- **WindowAdapter** para manejar los eventos de ventana (cerrarla, minimizarla, hacerla peque√±a). 
- **ActionListener ‚Üí** para especificar qu√© va a hacer una aplicaci√≥n al presionar un bot√≥n. 

-----

**APPLETS**

Programas escritos en **Java** (o cualquier lenguaje compatible con c√≥digo generado por Java como Jython y Scala, entre otros) y que forman parte de los componentes de una p√°gina web. Se utilizan para a√±adir funcionalidad a las p√°ginas web que no se pueden satisfacer utilizando solo HTML; y su objeto es ser lo suficientemente peque√±o para proporcionar una determinada funcionalidad bien definida. 

El c√≥digo del applet es ejecutado por el propio navegador utilizando la JVM, lo cual permite que el c√≥digo sea independiente del SO que ejecuta el navegador. 

Estos programas nacieron con Java (**1995**) y se fueron popularizando. No obstante, los applets (junto a Java) se enfrentan a grandes **cr√≠ticas por su seguridad**, lo que ha dado lugar a que cada vez m√°s sean los buscadores que bloquean las versiones anteriores de Java, en especial con la creciente popularidad HTML5. As√≠ pues, el uso de subprogramas ha disminuido convirti√©ndose en una **tecnolog√≠a que tiende a desaparecer.** 

**Applets vs Scripts Javascript ‚Üí** applets son m√°s dif√≠ciles de programar y requiere de conocimientos b√°sicos o medios del lenguaje Java.  No obstante, los applets son mucho menos dependientes del navegador y, dado que Java es m√°s potente que Javascript, el n¬∫ de aplicaciones de los applets podr√° ser mayor. 

Cabe destacar que los applets son m√°s lentos de procesar y tienen un espacio muy delimitado en la p√°gina donde se ejecutan, es decir no se mezclan con todos los componentes de la p√°gina ni tienen acceso a ellos. Es por ello que con los applets de Java no podremos hacer directamente cosas como abrir ventanas secundarias, controlar Frames, formularios, capas, etc. 

Algunos ejemplos de funciones que utilizan applets son: 

- Agregar secuencias de im√°genes y efectos visuales. 
- Agregar im√°genes con sonido y efectos sonoros. 
- Uso de funciones especializadas, como p.e, applets para calcular el valor del √°ngulo inscrito en una circunferencia y circuncentro de un tri√°ngulo. 
- Animaci√≥n de texto y efectos especiales. 
- Crear tablas y gr√°ficos. 
- Crear juegos simples. 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

**Creaci√≥n de un applet (ver ejemplos en proyecto ventana)**

Para crear un applet, se debe hacer a trav√©s de una **clase heredera de la clase Applet** (incluida en el paquete **java.applet**, por lo que debemos importar java.applet.\*). Si utilizamos la biblioteca de gr√°ficos **Swing**, se puede usar la clase **JApplet** (incluida en el paquete **javax.swing,** por lo que debemos importar javax.swing.JApplet) para heredar de √©sta en vez de la mencionada anteriormente.

-----

<a name="_bt9bcuj5kpx0"></a>**ACCESO A FICHEROS** 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.015.png)

Los ficheros de texto son los m√°s sencillos de manejar, √©stos pueden ser creados con un programa Java o un editor de texto y as√≠ mismo luego pueden ser le√≠dos desde el programa Java o desde el editor de texto. Son de gran utilidad, entre otras cosas porque nos permite salvar los datos de un programa en un fichero y luego restaurarlo (aunque si la cantidad de datos es muy grande lo m√°s apropiado es usar una base de datos). 



















El **tratamiento de ficheros** debe regirse por la siguiente secuencia ([Ejemplos](https://chuwiki.chuidiang.org/index.php?title=Lectura_y_Escritura_de_Ficheros_en_Java) ): 

1. **Abrir un fichero,** pues de lo contrario cuando queramos acceder al contenido saldr√° un error. 

- **FileReader ‚Üí** podemos abrir un fichero de texto para leer usando esta clase. √âsta nos permite leer caracteres. Sin embargo, esta clase no contiene m√©todos para leer l√≠neas completas. 

Para solventar este √∫ltimo problema, usamos la clase **BufferedReader (**recibe como par√°metro el fichero y como segundo par√°metro opcional el tama√±o del buffer**)** que si que permite leer l√≠neas completas, debemos construir/instanciar un *BufferedReader* a partir del *FileReader*. 

Cabe destacar el uso de algunos de los **m√©todos importantes de BufferedReader ([Ejemplos](http://ayudaitver.blogspot.com/2014/07/uso-basico-del-bufferedreader.html#metodos) )**: 

- **close() ‚Üí** vac√≠a el buffer (volc√°ndolo en el disco)  y lo cierra. 
- **mark(n¬∫) ‚Üí** establece una marca en la posici√≥n actual del apuntador del flujo. De forma que cuando se llame al m√©todo **reset()** se pueda regresar a la √∫ltima marca hecha. 

Cabe destacar que se debe pasar como par√°metro el n¬∫ de caracteres que pueden ser le√≠dos y a√∫n mantener la marca, es decir que si se rebasa ese n√∫mero de caracteres, la marca ser√° descartada y no se podr√° volver a ella. 

- **read() ‚Üí** lee un solo car√°cter del flujo y retorna un n¬∫ entero correspondiente al valor de c√≥digo ASCII que representa a ese car√°cter. Dado que el c√≥digo ASCII en la mayor√≠a de casos no ser√° de mucha utilidad, ser√° necesario hacer casting de entero a car√°cter. 
- **readLine() ‚Üí** lee una l√≠nea, es decir va leyendo caracteres hasta encontrarse con el car√°cter \n (salto de l√≠nea) o \r (retorno de carro). 
- **ready() ‚Üí** este m√©todo nos devuelve un boolean indicando si a√∫n hay caracteres en el flujo para ser le√≠dos, o por el contrario hemos alcanzado EOF (End Of File), que en el caso de los archivos de texto EOF = -1. 
- **skip(n¬∫) ‚Üí** mueve el apuntador del flujo las posiciones necesarias para evitar el n¬∫ de caracteres indicado como par√°metro. 
- **lines() ‚Üí** devuelve las l√≠neas que hay en el buffer de lectura. 

Como alternativa para leer un fichero de texto l√≠nea por l√≠nea, podr√≠a usarse **Scanner** tal y como se explica m√°s arriba (en paquetes). [Ejemplo de como hacerlo con Scanner](https://chuwiki.chuidiang.org/index.php?title=Lectura_de_teclado_en_java#Ejemplo_de_lectura_de_un_fichero_con_Scanner)  

- **FileWriter ‚Üí** podemos abrir un fichero de texto para escribir en √©l desde cero, en cuyo caso al instanciar un objeto de tipo FileWriter pasamos el nombre del fichero como par√°metro y ya; o bien si queremos a√±adir texto al final de un fichero ya existente, hacemos lo mismo pero pasamos un segundo par√°metro correspondiente a un boolean que true. 

En este caso ocurre lo mismo que con la lectura, si queremos ir l√≠nea por l√≠nea y no caracter por caracter, debemos hacer uso de **BufferedWriter (**recibe como par√°metro el fichero y como segundo par√°metro opcional el tama√±o del buffer**).**  

Cabe destacar el uso de algunos de los **m√©todos importantes de BufferedWriter**: 

- **close() ‚Üí** vac√≠a el buffer (volc√°ndolo en el disco)  y lo cierra. 
- **write(n¬∫) ‚Üí** escribe un solo car√°cter, que ser√° el pasado como par√°metro. Teniendo en cuenta que al igual que read(), trata los caracteres seg√∫n su c√≥digo ASCII.  
- **write(string, n¬∫offset, n¬∫) ‚Üí** escribe el string que se le indica como par√°metro. El segundo par√°metro deber√° indicar la posici√≥n a partir de la cual se va a escribir el string, p.e si es ‚ÄúHello Geeks‚Äù y ponemos un offset igual a 6, entonces lo que se escribir√° en el buffer ser√° ‚ÄúGeeks‚Äù . Por √∫ltimo debe pasarse un n¬∫ que indique el tama√±o (n¬∫ de caracteres) que tendr√° la cadena en cuesti√≥n. 
- **newLine() ‚Üí** escribe una l√≠nea de separaci√≥n. 
- **flush() ‚Üí** vac√≠a el buffer sin cerrarlo, es decir se limita a volcarlo en el disco**.**  

**\*\*Nota ‚Üí** si usamos FileReader o FileWriter para leer/escribir, se har√° f√≠sicamente sobre el disco duro, si vamos escribiendo y leyendo de pocos en pocos caracteres, el proceso se hace costoso y lento al implicar muchos accesos a disco duro. Es por ello que se recomienda el uso de los Buffered, pues lo que hacen es a√±adir un buffer intermedio, de forma que solo se accede al disco cuando el buffer se llena o cuando a trav√©s de un m√©todo se indica expresamente. 

1. **Leer/modificar/guardar datos.** 
1. **Cerrar el fichero,** pues de lo contrario es posible que no se guarde ning√∫n dato, ya que el buffer no llega a vaciarse (los datos preparados permanecen en la memoria intermedia hasta que el buffer se llene o se da el aviso de cierre y pasan a ser volcados en el disco). Es por este motivo que se suele incluir en el ***try-catch*** un ***finally*** con el close() dentro, de forma que siempre se garantice el cierre del fichero. 

La **clase File** es de gran importancia a la hora de tratar con ficheros pues como vemos en los ejemplos es lo que se utiliza en primer lugar para luego ya complementarlo con las clases vistas anteriormente, √©sta incluye los siguientes m√©todos (entre otros [Ejemplos](https://somoshackersdelaprogramacion.es/la-clase-file-de-java) ): 

`  `**\*\*** recordemos que previamente al uso de estos m√©todos, es necesario crear una instancia de File indicando la ruta en la que se encuentra (o encontrar√°) el archivo: 

- **NombreInstanciaFile.createNewFile()** ‚Üí Permite crear un archivo, devolviendo un boolean que indica si ha sido posible crear el fichero o no. 
- **NombreInstanciaFile.exists() ‚Üí** devuelve un boolean que indica si el fichero existe o no. 
- **NombreInstanciaFile.isFile()** o **NombreInstanciaFile.isDirectory() ‚Üí** devuelve un boolean indicando si es un fichero o un directorio respectivamente seg√∫n usemos uno u otro. 
- **NombreInstanciaFile.canRead()** o **canWrite()** o **canExecute() ‚Üí** devuelve un boolean indicando si se tiene o no el permiso, seg√∫n se use un m√©todo u otro. 
- **NombreInstanciaFile.delete() ‚Üí** permite borrar el fichero. Conviene despu√©s de borrar comprobar si existe. 
- **NombreInstanciaFile.getAbsolutePath() ‚Üí** permite obtener la ruta completa del fichero. 
- **NombreInstanciaFile.getName() ‚Üí** permite obtener el nombre del fichero. 
- **NombreInstanciaFile.getParent() ‚Üí** permite obtener la ruta padre, es decir la ruta del directorio que contiene un fichero. 
- **NombreInstanciaFile.length() ‚Üí** permite obtener el tama√±o de un fichero en bytes. 
- **NombreInstanciaFile.isHidden() ‚Üí** devuelve un boolean que indica si el fichero est√° oculto o no. 
- **NombreInstanciaFile.listFiles() ‚Üí** devuelve un array de objeto de tipo File, es decir un array que contiene todos los ficheros y directorio de un determinado directorio. 
- **NombreInstanciaFile.mkdir() ‚Üí** permite crear un directorio. 
- **NombreInstanciaFile.setExecutable(boolean)** o **setReadable** o **setWritable ‚Üí** seg√∫n se indique en el boolean que se pasa por par√°metro permite establecer los permisos de un fichero.
-----

<a name="_6qb9sbb7gi5y"></a> **MULTITAREA ([Buenos Apuntes](http://informatica.uv.es/iiguia/LP/teoria/apuntes/cuatr1/tema3_2_concurrencia2.pdf) )**

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.016.png)

Java trae un soporte integrado dise√±ado exclusivamente para la programaci√≥n **multihilo/multithread**, este tipo de programas constan de varias partes en su c√≥digo (donde cada una de ellas reciben el nombre de **hilo o thread**) que se pueden ejecutar de manera simult√°nea e independiente. 

Existen **dos tipos de multitarea**: 

- **Multitarea basada en procesos ‚Üí** teniendo en cuenta que un **proceso** es un programa en ejecuci√≥n. Este tipo de multitarea basada en procesos permite que se puedan ejecutar varios programas a la vez. 


- **Multitarea basada en hilos ‚Üí** teniendo en cuenta que un **hilo o subproceso** es la unidad de c√≥digo m√°s peque√±a que se puede distribuir y que NO pueden existir fuera de un proceso (pues pertenece a √©l); todo proceso cuenta con m√≠nimo un hilo de ejecuci√≥n ‚Äú*hilo principal*‚Äù que se establece al iniciar un programa. Este tipo de multitarea basada en hilos permite que un programa pueda realizar muchas tareas (ejecutar muchos hilos) al mismo tiempo. 

**Ventajas ‚Üí** permite escribir c√≥digo m√°s eficientemente, pues los programas pueden realizar diferentes tareas durante un tiempo de inactividad, haciendo el programa mucho m√°s potente. P.e cuando un hilo/(parte) de nuestro programa env√≠a un archivo a trav√©s de internet, otro hilo/(parte) puede leer la entrada del teclado y otro hilo/(parte) puede almacenar el siguiente bloque de datos para enviar. 

Es importante comprender que la naturaleza multiproceso de Java se aplica tanto a **sistemas multiprocesador** (varias CPUs/procesadores) como a **sistemas monoprocesador** (una sola CPU/procesador). En √©ste √∫ltimo caso (sistemas monoprocesador), en el que solo existe un n√∫cleo, la CPU se comparte mediante la ejecuci√≥n simult√°nea de subprocesos(hilos), cada uno de los cuales contiene un bloque de tiempo de CPU. 

Cabe destacar que en un sistema monoprocesador no es que se est√©n ejecutando los hilos al mismo tiempo, sino que se usa el tiempo de inactividad de la CPU, es decir se van otorgando tiempos a cada uno de los hilos, siendo estos tiempos tan r√°pidos que da la sensaci√≥n de que todo est√° pasando de forma simult√°nea (**conmutaci√≥n de contextos**). Mientras que en los multiprocesador si que pueden ejecutarse diferente subprocesos/hilos a la vez. 

`	`**‚Äî--------------------------------------------------------------------------------------------------------------------------------------------**

**Clase Thread**

Clase inclu√≠da en **java.lang**, permite gestionar los hilos a trav√©s de sus **m√©todos**, entre los cuales destacan: 

- **start() ‚Üí** m√©todo que inicia la ejecuci√≥n de la tarea/subproceso/hilo. El m√©todo invoca a run() y devuelve inmediatamente el control a la tarea/hilo/subproceso que lo ha llamado. 

Se debe tener en cuenta que si el sistema s√≥lo tiene n√∫cleo, no se ejecutan varios subprocesos a la vez, sino que se usa el tiempo de inactividad de la CPU, a diferencia de un multiprocesador. 

- **stop() ‚Üí** m√©todo que hace que se detenga un determinado hilo inmediatamente. Esta suele ser una forma tosca de parar un subproceso, especialmente si se ejecuta en el subproceso actual; es por ello que para parar un hilo de una manera m√°s sofisticada se recomienda mejor el uso de algunas variables para que el m√©todo run() salga ordenadamente. 

- **run() ‚Üí** m√©todo que forma la estructura principal de los hilos que se est√°n ejecutando, este m√©todo es el √∫nico que tiene la interfaz Runnable y se invoca mediante start(). Es por esto que todas las clases derivadas de Thread deben de sobrescribir el m√©todo run(). 

La ejecuci√≥n del m√©todo run de un Thread puede realizarse **concurrentemente** con otros m√©todo run de otro Thread y con el m√©todo main. 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.017.png)![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.018.png)













- **currentThread() ‚Üí** devuelve un objeto de tipo hilo/subproceso correspondiente al subproceso que se est√° ejecutando actualmente. 
- **sleep(n¬∫) ‚Üí** permite suspender el subproceso actual durante el **n¬∫ de milisegundos** especificado como par√°metro. Pasados los milisegundos indicados, el hilo estar√° nuevamente disponible. (Los relojes asociados con la mayor√≠a de los int√©rpretes de Java no podr√°n lograr una precisi√≥n superior a 10 ms). 
- **yield() ‚Üí** permite cambiar el contexto entre el subproceso actual y el siguiente subproceso en ejecuci√≥n que se encuentre disponible, es decir el hilo actual cede su tiempo de CPU. De esta manera se garantiza que los subprocesos de baja prioridad/importancia no se queden sin recursos, es decir, tambi√©n puedan tener el tiempo de CPU que les corresponda. 
- **suspend() ‚Üí** toma un subproceso y hace que pare la ejecuci√≥n sin llegar a finalizar el subproceso del sistema ni el estado de un subproceso en ejecuci√≥n anterior. 

Si se suspende la ejecuci√≥n de un subproceso, podemos llamar al m√©todo resume() en el mismo proceso y ejecutarlo nuevamente. 

- **resume() ‚Üí** se usa principalmente para reanudar un hilo que est√° en estado de suspensi√≥n. No existe ninguna garant√≠a de que vaya a iniciarse el hilo de inmediato, ya que es posible que un subproceso con m√°s prioridad se encuentre ejecut√°ndose en ese momento, pero el m√©todo resume() hace que vuelva a ser un candidato a ser ejecutado. 
- **getPriority() ‚Üí** devuelve la prioridad del subproceso actual, es decir, un valor entre 1 y 10. 
- **setPriority(n¬∫) ‚Üí**  asigna al hilo la prioridad indicada por el argumento que se pasa. La clase Thread facilita **constantes predefinidas** para la prioridad como: 

- MIN\_PRIORITY ‚Üí 1
- NORM\_PRIORITY ‚Üí 5
- MAX\_PRIORITY ‚Üí 10

- **setName(String) ‚Üí** este m√©todo permite identificar al hilo con un **nombre menm√≥nico,** por lo que se puede depurar mejor los programas multihilo. Este nombre aparecer√° en todas las l√≠neas de trazado que se muestran cada vez que el int√©rprete Java imprime excepciones no capturadas. Por otro lado, **getName()** nos devuelve el valor actual (tipo String) asignado como nombre al hilo en ejecuci√≥n mediante *setName()*. 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.019.png)

El hilo se encuentra ‚Äúvivo‚Äù cuando est√° en estado ‚ÄúEjecutable‚Äù o ‚ÄúNo ejecutable‚Äù. 




![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.020.png)![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.021.png)














![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.022.png)![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.023.png)

El criterio para la ejecuci√≥n de m√∫ltiples hilos sobre una CPU se basa en prioridades, de forma que se ejecuta en cada instante el hilo con prioridad m√°s alta (si tuviesen la misma prioridad se selecciona de forma arbitraria). Los **hilos heredan la prioridad del hilo que los crea**, y los hilos de prioridad baja s√≥lo se podr√°n ejecutar cuando todos los hilos de prioridad superior pasen al estado ‚ÄúNo ejecutable‚Äù. 

**Interfaz Runnable**

En el caso de que queramos hacer concurrentes objetos heredados de otra clase que no sea Thread (p.e un Objeto C√≠rculo que hereda de la clase Figura), nos encontramos con un problema y es que no podemos hacer que tambi√©n herede de Thread. Ya que Java admite heredar solo de 1 clase pero implementar m√∫ltiples interfaces; es por eso que en tales casos se deber√° de utilizar la **interfaz Runnable**. El funcionamiento es muy similar, aunque con ciertas diferencias: 

- La interfaz no se hereda, se implementa. 
- Al igual que con Thread, la clase que implemente la interfaz Runnable tambi√©n deber√° implementar el m√©todo *run()*. 
- El lanzamiento de una tarea no se puede hacer directamente con start() porque el objeto creado no ser√° un hilo, sino que deber√° de crearse un hilo de ejecuci√≥n con Thread al que se pasar√° el objeto que implementa la interfaz Runnable y ya posteriormente usar el m√©todo start. 

P.e 

`	`**class Circulo extends Figura implement Runnable {...}** 

`	`**Circulo c = new Circulo();**

`	`**Thread elHilo = new Thread(c);** 

`	`**elHilo.start();** 

Como vemos el mecanismo es m√°s indirecto que heredar de Thread, pero evita el problema de la herencia m√∫ltiple. 

**Sincronizaci√≥n de hilos**

La sincronizaci√≥n se basa en el concepto **monitor** (no es un hilo, sino un objeto ‚Äúnormal‚Äù al que pueden acceder varios Thread), aunque no existe ese tipo de datos como predefinido (no hace falta ya que Java asocia un monitor a todos los objetos). 

Java trata de manera autom√°tica el problema de la exclusividad de acceso a un objeto mediante la definici√≥n de m√©todo (o bloques) ***synchronized***. De forma que el programador debe preocuparse de tratar la sincronizaci√≥n de tipo **Cooperaci√≥n**, que se realiza mediante las operaciones ***wait()/notify()***.

El **monitor** permite hacer un objeto de acceso seguro que asegura el uso excluyente del objeto, es decir que en cada instante s√≥lo una tarea est√° haciendo uso de √©l, para ello (que un m√©todo se considere monitor) dicho m√©todo p√∫blico debe definirse como ***synchronized***.  Dentro de dicho m√©todo se utilizar√°n los m√©todos: 

- ***wait() ‚Üí*** el hilo actual se espera hasta que otro hilo env√≠e una notificaci√≥n (notify) al mismo objeto. Es probable que wait lance Excepci√≥n, por lo que se recomienda hacer catch de *InterruptedException***.** 
- ***notify() ‚Üí*** activa un hilo que est√° esperando en el monitor del objeto. 
- ***notifyAll()*** ‚Üí activa todos los hilos que est√°n esperando en el monitor del objeto, por lo que los hilos ‚Äúcompiten‚Äù por el objeto y s√≥lo uno obtiene el bloqueo. 

-----

**MODELO TRES CAPAS**

La arquitectura de tres capas es un dise√±o que a√±ade un nivel intermedio en el proceso. Las **capas** son independientes que se ejecutan en una plataforma diferentes 

En las arquitecturas **tradicionales** de tres capas,se instala la interfaz de usuario en el ordenador del usuario final (cliente), mientras que la arquitectura **basada en web** transforma la interfaz de b√∫squeda (navegador web) en una interfaz de usuario final. 

![](Aspose.Words.ce493cb2-47e8-494b-b1ec-dbd7691ec639.024.png)

- **Primera capa [cliente de la app, navegador web] ‚Üí** nivel de **presentaci√≥n**, que incluye no solo el navegador, sino tambi√©n el servidor web responsable de presentar los datos en un formato adecuado (formato en el que lo ve el cliente). Corresponde a la capa **vista** del MVC que define los elementos destinados a representar la informaci√≥n y a interactuar con el usuario, abarcando el c√≥digo de la app encargado de reproducir la visualizaci√≥n de las interfaces de usuarios, es decir c√≥digo encargado de renderizar los estado de nuestra app en HTML. 

Es por tanto, la representaci√≥n del modelo, es decir los datos y la l√≥gica del negocio, de una manera adecuada para que el cliente pueda interactuar. As√≠ pues, la vista demanda la informaci√≥n al modelo por medio del controlador, ya que la vista trabaja con los datos pero no tiene un acceso directo a √©stos. 

- **Segunda capa [servidores de apps, *Apache, Tomcat, servlets*] ‚Üí** generalmente se refiere a alg√∫n tipo de programa o script. Se corresponde con la capa **controlador** de MVC, definiendo los procedimientos para tratar tanto las informaci√≥n y transformar la petici√≥n y respuestas del servidor, pues contiene el c√≥digo necesario para responder a las acciones que se solicitan en la aplicaci√≥n. No obstante, no se encarga de manipular directamente datos (lo hace el modelo), ni mostrar ning√∫n tipo de salida (lo hace la vista), sino de servir de enlace/intermediario entre los modelos y vistas. 

Tambi√©n se encarga de enviar √≥rdenes a la visa si se reciben peticiones en la manera de mostrar el modelo (la informaci√≥n). 

- **Tercera capa [servidores de datos *bases de datos, servidores SMTP, etc*] ‚Üí** proporciona a la segunda los datos que necesita para ejecutarse. Corresponde a la capa **modelo** del MVC, trabaja con la recuperaci√≥n y almacenamiento propiamente de los datos, pues es la capa en la que se trabaja con los datos, por lo que define mecanismos para acceder a la informaci√≥n y actualizar su estado, a trav√©s de funciones que acceder√°n a las tablas de la base de datos. 

Administra todas las peticiones de informaci√≥n, incluyendo consultas y modificaciones; y define los privilegios de acceso que requerir√° la l√≥gica de negocio. Env√≠a a la vista a trav√©s del controlador, la informaci√≥n solicitada para que pueda ser mostrada al cliente. 

**Ventajas** 

- Las llamadas desde la interfaz de usuario al servidor del nivel medio (controlador) son m√°s flexibles que el dise√±o de dos niveles porque solo se necesita pasar par√°metros al nivel medio. 
- La interfaz no necesita comprender o comunicarse con el destinatario de los datos (modelo), por lo que la estructura de datos se puede modificar sin cambiar la interfaz de usuario en el PC. 
- Si se dise√±a en un formato modular (como hacemos en Django con Python) , varias aplicaciones pueden reutilizar el c√≥digo de nivel medio (pues se encuentra separado). Por eso mismo, los roles se pueden dividir en tres capas y una capa se puede reemplazar o modificar f√°cilmente sin afectar al resto de los m√≥dulos. 
- Se decide qu√© parte l√≥gica de la aplicaci√≥n procedemos a encapsular en cada uno de nuestros componentes de la misma manera que encapsulamos los componentes en varios niveles. Por lo que permite construir componentes f√≠sicos a trav√©s de los niveles l√≥gicos. 

**Desventajas**

- Implican un aumento en el tr√°fico de red y requiere m√°s equilibrio de carga o tolerancia a fallos.
- Los navegadores actuales no son todos iguales y es algo a tener en cuenta. 

-----

**PROTOCOLO HTTP (Hypertext Transfer Protocol)**

Concepto desarrollado por Tim Berners-Lee (CERN, Suiza) que constituye la base de la World Wide Web, as√≠ como **HMTL (**lenguaje de marcado de hipertexto que define la estructura de la p√°gina web**)** y **URI (**deriva en un **URL**, Uniform Resource Locator que define la ubicaci√≥n de un recurso, como una p√°gina web en Internet**). HTTP** es el c√≥digo o lenguaje en el que el navegador se comunica con el servidor para indicar la p√°gina que quiere ver, y a su vez especifica c√≥mo el servidor env√≠a el recurso al cliente. 

Procedimiento: 

1. El usuario en la barra de direcciones del navegador (cliente) indica la URL. 
1. El navegador env√≠a una solicitud HTTP al servidor web que administra el dominio indicado en la URL. 
1. El servidor web recibe la solicitud HTTP, busca el recurso y env√≠a una cabecera que indica a trav√©s de un c√≥digo de estado los resultados de la b√∫squeda., as√≠ como el recurso en caso de que el cliente no solo haya preguntado por su existencia sino que haya solicitado recibirlo (p.e HTML si se trata de una p√°gina web). 
1. El navegador recibe el archivo y lo abre como una p√°gina web. 

**M√©todos,** permiten identificar la acci√≥n que queremos realizar sobre un determinado recurso y utilizar REST**:** 

- **GET ‚Üí** m√©todo que no cambia el estado del recurso, sino que busca obtener informaci√≥n del mismo (pudiendo obtenerla de una cach√©). Es **idempotente**, ya que puedo solicitar dicha informaci√≥n 20 veces o una vez que siempre voy a tener el mismo resultado; adem√°s es **seguro** porque no conlleva la modificaci√≥n del recurso solicitado. (no lleva cuerpo).

- **POST ‚Üí** solicita informaci√≥n y se diferencia del GET porque lleva cuerpo y permite llevar informaci√≥n en √©l, ya que se suele usar para crear un nuevo recurso conociendo la URL de un constructor de recursos, es decir la URL a la que se hace la petici√≥n permite la creaci√≥n de recursos; as√≠ pues cambia el estado. **No es** **idempotente,** ya que a diferencia de lo que ocurre con PUT, si se produjese un fallo de timeout (se ha superado el tiempo de espera de respuesta a la petici√≥n) y por ende el usuario no supiese si fue creado o no el recurso y repitiera la petici√≥n reiteradamente, habr√≠a un problema y es que se podr√≠an obtener muchas creaciones de un mismo recurso. Adem√°s **no es seguro.** (lleva cuerpo). 

- **PUT ‚Üí** se enfoca en editar valores del servidor, pues permite actualizar o crear un recurso conocida su URL, as√≠ pues cambia el estado del recurso, siendo el cuerpo de la petici√≥n donde ir√° la representaci√≥n completa del recurso. Es **idempotente** ya que en el caso en que se produjese un fallo de timeout (se supera el tiempo de espera de respuesta a la petici√≥n) y el usuario repitiese la petici√≥n reiteradamente porque no sabe si fue creado o actualizado el recurso, no habr√≠a ning√∫n problema, ya que en el caso de haber creado un recurso, una nueva petici√≥n PUT no crear√≠a otro recurso m√°s sino que lo actualiza sin verse afectado el resultado. Adem√°s, **no es seguro.** 



- **DELETE ‚Üí** m√©todo que borra un recurso conocida su URL. Es **idempotente,** ya que una vez borrado un elemento si lo borro muchas m√°s veces el resultado es el mismo desde la primera vez que lo hago que es borrarlo; y adem√°s **no es seguro** ya que modifica el recurso al borrarlo. 

-----

**ARQUITECTURA JAVA EE**

La plataforma Java EE es un conjunto de especificaciones de API que le permiten crear aplicaciones web. Java EE proporciona un **perfil web** y un **modelo de aplicaci√≥n estandarizado**, lo que permite la definici√≥n de una arquitectura para implementar aplicaciones de varios niveles. En una **aplicaci√≥n multinivel**, la funcionalidad de la aplicaci√≥n se divide en varias √°reas denominadas **niveles:** 

- **Nivel de cliente ‚Üí** es el m√°s alto de la arquitectura Java EE, y es el punto en el que los clientes de la aplicaci√≥n pueden realizar peticiones a un servidor Java EE, normalmente ubicado en otra m√°quina, en otra zona a pocos kil√≥metros del servidor Java EE. Asimismo, cuando un cliente env√≠a una solicitud a un servidor, el servidor la recibe, la procesa y devuelve una respuesta basada en la solicitud. 

- **Nivel web ‚Üí** nivel encargado de gestionar la interacci√≥n entre el nivel de cliente y el nivel posterior (**nivel de negocio**). El funcionamiento de este nivel se compone de los siguientes pasos: 

- Recolectar datos ingresados por los clientes. 
- Administrar el flujo de p√°ginas de clientes (y navegaci√≥n). 
- La informaci√≥n y el estado de los datos de la sesi√≥n son mantenidos por el cliente. 
- Obtener resultados de la capa de negocio a partir de los componentes. 
- Presentar al cliente los datos obtenidos de la capa de negocio. 

Si una aplicaci√≥n web utiliza componentes y servicios Java EE se puede definir en el nivel web de la aplicaci√≥n como una **aplicaci√≥n empresarial de tipo Java EE.** 

El **contenedor web (navegador)** es el responsable de implementar todas las especificaciones de la API, adem√°s de proporcionar servicios para la gesti√≥n y ejecuci√≥n de componentes web como servlets, JSP, filtros, oyentes, etc. 

**Estructura de una aplicaci√≥n web Java EE**

Una aplicaci√≥n web J2EE que utiliza servlets o p√°ginas JSP debe tener una **estructura de archivos y directorios** espec√≠fica: 

- **P√°ginas HTML o JSP** se colocan en el **directorio ra√≠z** de la aplicaci√≥n (tambi√©n podemos utilizar subdirectorios seg√∫n sea necesario). 
- **Colgando del directorio principal** de la aplicaci√≥n hay un directorio **WEB-INF** que contiene informaci√≥n web relacionada con la aplicaci√≥n. Esta informaci√≥n se divide en: 

- Un **fichero descriptor** de despliegue de la aplicaci√≥n, se trata de un archivo XML (llamado **web.xml**) que contiene informaci√≥n general sobre la aplicaci√≥n. 
- **Subdirectorio *classes*** que contiene todas las **clases de Java** (Archivos **.class**) utilizadas en la aplicaci√≥n, es decir clases fuera de la API de Java para p√°ginas JSP, servlets, etc. Las clases deben mantener la estructura del paquete, es decir si pusieramos la clase paquete1.subpaquete1.Miclase dentro de una clase, quedar√≠a almacenada en el directorio classes/paquete1/subpaquete1/MiClase. 
- **Subdirectorio lib** donde colocaremos las clases de Java empaquetadas en el **archivo JAR**, es decir colocaremos el archivos JAR para nuestra app web y las bibliotecas JSP o servlet requeridas). 
- El resto de **elementos de la app** (im√°genes, etc), los podemos estructurar como mejor nos parezca. 

-----

<a name="_na9xy8wfbmgf"></a>**EXTRAS**

**> dynamic ‚Üí** tipo de datos que permite al compilador diferir la verificaci√≥n de tipo hasta el tiempo de ejecuci√≥n en lugar del tiempo de compilaci√≥n. Esto significa que el tipo se determina en tiempo de ejecuci√≥n en lugar de estar expl√≠citamente definido en el c√≥digo fuente. 

As√≠ pues, este tipo de datos permite trabajar con objetos sin conocer su tipo exacto de antemano. Puede acceder a sus propiedades y m√©todos como si fueran miembros de un objeto est√°tico, y el compilador no verifica el tipo hasta que se ejecuta el programa, es decir no nos salta ese error que no deja compilar. 

Su uso puede ser √∫til en situaciones en la que no se sabe exactamente el tipo de objeto que se recibir√° en tiempo de ejecuci√≥n (como la comunicaci√≥n con servidores web, BBDD o sistemas externos). No obstante su uso excesivo puede hacer el c√≥digo dif√≠cil de leer y mantener, por lo que debe usarse con moderaci√≥n. 

